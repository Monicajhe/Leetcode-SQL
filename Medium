# 177. Nth Highest Salary
1) https://leetcode.com/problems/nth-highest-salary/discuss/1013080/Mysql-%3A-Order-by-Limit
CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INT
BEGIN
SET N = N - 1;
  RETURN (
      # Write your MySQL query statement below.
      SELECT DISTINCT Salary
      FROM Employee 
      ORDER BY Salary DESC
      LIMIT 1 OFFSET N
  );
END
2)
CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INT
BEGIN
  RETURN (
      # Write your MySQL query statement below.
      SELECT DISTINCT Salary
      FROM (SELECT Salary, DENSE_RANK() OVER (ORDER BY Salary DESC) AS rnk
            FROM Employee) t
      WHERE N = rnk
  );
END

"""

# 178. Rank Scores
1)
SELECT Score AS score, DENSE_RANK() OVER (ORDER BY Score DESC) AS 'rank'
FROM Scores
2) https://leetcode.com/problems/rank-scores/discuss/456610/MySQL-Two-Simple-Solutions-and-Explanations-for-Beginners
SELECT S.Score, COUNT(S2.Score) AS 'Rank'
FROM Scores S, (SELECT DISTINCT Score FROM Scores) S2
WHERE S.Score<=S2.Score
GROUP BY S.Id 
ORDER BY S.Score DESC;

"""

# 180. Consecutive Numbers
1)
SELECT DISTINCT l2.Num AS ConsecutiveNums
FROM Logs l1, Logs l2, Logs l3
WHERE l2.Id - l1.Id = 1 AND l3.Id - l2.Id = 1
AND l1.Num = l2.Num AND l2.Num = l3.Num;
2)
select distinct Num as ConsecutiveNums
from Logs
where (Id + 1, Num) in (select * from Logs) and (Id + 2, Num) in (select * from Logs)
3) 
SELECT DISTINCT Num AS ConsecutiveNums
FROM (SELECT Id, Num,
      LAG(Num, 1) OVER (ORDER BY Id) AS Num_before,
      LEAD(Num, 1) OVER (ORDER BY Id) AS Num_after
      FROM Logs) t
WHERE Num = Num_before AND Num = Num_after;

"""

184. Department Highest Salary
1)
SELECT Department, Employee, Salary
FROM 
(SELECT d.Name AS Department, e.Name AS Employee, e.Salary,
        RANK() OVER (PARTITION BY d.Name ORDER BY e.Salary DESC) AS rnk
 FROM Employee e 
 JOIN Department d 
 ON e.DepartmentId = d.Id) t
WHERE rnk = 1;
2)
SELECT D.Name AS Department ,E.Name AS Employee ,E.Salary 
from Employee E
JOIN Department D 
ON E.DepartmentId = D.id 
WHERE (DepartmentId,Salary) in (SELECT DepartmentId,max(Salary) 
                                FROM Employee 
                                GROUP BY DepartmentId)
3)
select Department.Name as Department, e1.Name as Employee, Salary
from Employee e1, Department
where e1.DepartmentId = Department.Id 
and Salary >= ALL (select Salary from Employee e2 where e2.DepartmentId = e1.DepartmentId);
4)
SELECT dep.Name as Department, emp.Name as Employee, emp.Salary 
from Department dep, Employee emp 
where emp.DepartmentId=dep.Id 
and emp.Salary=(Select max(Salary) from Employee e2 where e2.DepartmentId=dep.Id)

"""

# 534. Game Play Analysis III
1)
SELECT player_id, 
       event_date, 
       SUM(games_played) OVER (PARTITION BY player_id ORDER BY event_date) AS games_played_so_far
FROM Activity;
2)
select player_id, 
       event_date, 
       (select sum(games_played) 
       from Activity 
       where player_id = a.player_id and event_date<=a.event_date) as "games_played_so_far"
from Activity a
3)
select a1.player_id, a1.event_date, sum(a2.games_played) as "games_played_so_far"
from
Activity a1 left join Activity a2
on a1.player_id = a2.player_id 
and a2.event_date<=a1.event_date
group by a1.player_id, a1.event_date
4)
select a1.player_id, a1.event_date, sum(a2.games_played) as games_played_so_far
from Activity a1, Activity a2
where a1.player_id = a2.player_id and a2.event_date <= a1.event_date
group by a1.player_id, a1.event_date
order by a1.player_id, a1.event_date

"""

# 550. Game Play Analysis IV
1) https://leetcode.com/problems/game-play-analysis-iv/discuss/508062/MySQL-Without-JOIN-with-Explanation
SELECT ROUND(COUNT(DISTINCT player_id) / (SELECT COUNT(DISTINCT player_id) FROM Activity), 2) AS fraction
FROM activity
WHERE (player_id, SUBDATE(event_date, 1)) IN (SELECT player_id, MIN(event_date) 
                                              FROM Activity
                                              GROUP BY player_id)
2) https://leetcode.com/problems/game-play-analysis-iv/discuss/324851/MySQL-solution-with-STEP-BY-STEP-explanation
SELECT ROUND(SUM(CASE WHEN a.event_date + 1 = b.event_date THEN 1 ELSE 0 END)/COUNT(DISTINCT a.player_id), 2) AS fraction 
FROM (SELECT player_id, MIN(event_date) AS event_date
      FROM Activity 
      GROUP BY player_id) AS a 
JOIN Activity AS b 
ON a.player_id = b.player_id
3) https://leetcode.com/problems/game-play-analysis-iv/discuss/995878/Using-LEAD-Straight-solution
SELECT ROUND(COUNT(DISTINCT player_id) / (SELECT COUNT(DISTINCT player_id) FROM Activity), 2) AS fraction
FROM (SELECT player_id, 
      MIN(event_date) OVER (PARTITION BY player_id) AS first_date, 
      LEAD(event_date, 1) OVER (PARTITION BY player_id ORDER BY event_date) AS date_after
      FROM Activity) t
WHERE date_after - first_date = 1

"""

# 570. Managers with at Least 5 Direct Reports
1)
SELECT DISTINCT e.Name
FROM Employee e
JOIN (SELECT ManagerId, COUNT(Id) OVER (PARTITION BY ManagerId) AS num
      FROM Employee) t
ON t.ManagerId = e.Id
WHERE num >= 5
2)
SELECT Name
FROM Employee
WHERE Id IN (SELECT ManagerId
             FROM Employee
             GROUP BY ManagerId
             HAVING COUNT(Id) >= 5);
3)
SELECT e2.Name
FROM Employee e1 
JOIN Employee e2
ON e1.managerId = e2.Id
GROUP BY e1.managerId
HAVING COUNT(e1.managerId)>=5

"""

# 574. Winning Candidate
1)
SELECT c.Name
FROM Candidate c
JOIN (SELECT CandidateId, COUNT(*) AS num
      FROM Vote
      GROUP BY CandidateId
      ORDER BY num DESC
      LIMIT 1) t
ON c.id = t.CandidateId;
2)
SELECT c.Name
FROM Candidate c
JOIN (SELECT CandidateId, 
             COUNT(CandidateId) OVER (PARTITION BY CandidateId) AS num
      FROM Vote) t
ON c.id = t.CandidateId
ORDER BY num DESC
LIMIT 1;

"""

# 578. Get Highest Answer Rate Question

SELECT question_id AS survey_log
FROM survey_log
GROUP BY question_id
ORDER BY SUM(action = 'answer') / COUNT(*) DESC
LIMIT 1;

"""

# 580. Count Student Number in Departments
1)
SELECT dept_name, COUNT(student_id) AS student_number
FROM department
LEFT JOIN student 
USING (dept_id)
GROUP BY dept_name
ORDER BY 2 DESC, 1
2) https://leetcode.com/problems/count-student-number-in-departments/discuss/734641/MySQL%3A-Using-SUM(CASE-WHEN...)-instead-of-COUNT
SELECT dept_name, SUM(CASE WHEN s.dept_id THEN 1 ELSE 0 END) as student_number
FROM department d LEFT JOIN student s ON d.dept_id = s.dept_id
GROUP BY 1
ORDER BY 2 desc, 1

"""

# 585. Investments in 2016
1)
SELECT SUM(TIV_2016) AS TIV_2016
FROM insurance
WHERE TIV_2015 IN (SELECT TIV_2015
                   FROM insurance
                   GROUP BY TIV_2015
                   HAVING COUNT(TIV_2015) > 1)
AND (LAT, LON) IN (SELECT LAT, LON
                  FROM insurance
                  GROUP BY LAT, LON
                  HAVING COUNT(*) = 1)
2)
SELECT SUM(TIV_2016) AS TIV_2016
FROM
(SELECT *,
COUNT(*) OVER(PARTITION BY TIV_2015) AS CNT1,
COUNT(*) OVER(PARTITION BY LAT, LON) AS CNT2
FROM INSURANCE
) t
WHERE CNT1 > 1 AND CNT2 = 1

"""

# 602. Friend Requests II: Who Has the Most Friends

SELECT id1 AS id, COUNT(*) AS num
FROM (
    SELECT requester_id AS id1, accepter_id AS id2
    FROM request_accepted
    UNION 
    SELECT accepter_id AS id1, requester_id AS id2
    FROM request_accepted
    ) t
GROUP BY id1
ORDER BY num DESC
LIMIT 1;

# 608. Tree Node
1) https://leetcode.com/problems/tree-node/discuss/219003/Need-help-!!-what's-wrong-with-my-code
SELECT id, CASE WHEN p_id IS NULL THEN 'Root'
                WHEN id NOT IN (SELECT DISTINCT p_id 
                                FROM tree
                                WHERE p_id IS NOT NULL) THEN 'Leaf'
                ELSE 'Inner' END AS Type
FROM tree
2) https://leetcode.com/problems/tree-node/discuss/104112/Solution-with-explanation%3A-CASE-%2B-LEFT-JOIN
SELECT DISTINCT t1.id, (
    CASE
    WHEN t1.p_id IS NULL  THEN 'Root'
    WHEN t1.p_id IS NOT NULL AND t2.id IS NOT NULL THEN 'Inner'
    WHEN t1.p_id IS NOT NULL AND t2.id IS NULL THEN 'Leaf'
    END
) AS Type 
FROM tree t1
LEFT JOIN tree t2
ON t1.id = t2.p_id
3)
select id,
case when p_id is null then 'Root'
when id in (select distinct p_id from tree) then 'Inner'
else 'Leaf'
end as 'Type'
from tree

"""

# 612. Shortest Distance in a Plane
1)
SELECT ROUND(MIN(SQRT(POWER(x1 - x2, 2) + POWER(y1 - y2, 2))), 2) AS shortest
FROM (SELECT p1.x AS x1, p2.x AS x2, p1.y AS y1, p2.y AS y2
      FROM point_2d p1
      CROSS JOIN point_2d p2
      WHERE (p1.x, p1.y) != (p2.x, p2.y)) t
2)
SELECT ROUND(MIN(SQRT(POWER(p1.x - p2.x, 2) + POWER(p1.y - p2.y, 2))), 2) AS shortest
FROM point_2d p1,point_2d p2
WHERE (p1.x, p1.y) != (p2.x, p2.y) 

"""

# 614. Second Degree Follower
1)
SELECT f1.follower, COUNT(DISTINCT f2.follower) AS num
FROM follow f1, follow f2
WHERE f1.follower = f2.followee
GROUP BY f1.follower
ORDER BY 1;
2)
SELECT followee AS follower, COUNT(DISTINCT follower) AS num
FROM follow
WHERE followee IN (SELECT DISTINCT follower
                   FROM follow)
GROUP BY followee
ORDER BY followee;

"""

# 626. Exchange Seats
1)
SELECT (CASE WHEN id % 2 = 0 THEN id - 1 
             WHEN id % 2 = 1 AND id != (SELECT COUNT(*) FROM seat) THEN id + 1
             ELSE id END) AS id,
        student
FROM seat 
ORDER BY id;
2)
SELECT id,
       IFNULL((CASE WHEN id % 2 = 1 THEN LEAD(student, 1) OVER (ORDER BY id)
             ELSE LAG(student, 1) OVER (ORDER BY id) END), student) AS student 
FROM seat 
ORDER BY id;

"""

# 1045. Customers Who Bought All Products

SELECT customer_id
FROM Customer
GROUP BY customer_id
HAVING COUNT(DISTINCT product_key) = (SELECT COUNT(*) FROM Product)

"""

# 1070. Product Sales Analysis III
1)
SELECT product_id, year AS first_year, quantity, price
FROM Sales
WHERE (product_id, year) IN (SELECT product_id, MIN(year) 
                             FROM Sales
                             GROUP BY product_id);
2)
SELECT product_id, year AS first_year, quantity, price
FROM (SELECT *, RANK() OVER (PARTITION BY product_id ORDER BY year) AS rnk
      FROM Sales) t
WHERE rnk = 1;

"""

# 1077. Project Employees III
1)
WITH t AS (SELECT project_id, 
                  employee_id,
                  RANK() OVER (PARTITION BY project_id ORDER BY experience_years DESC) AS rnk
           FROM Project
           JOIN Employee 
           USING (employee_id))

SELECT project_id, employee_id
FROM t
WHERE rnk = 1;
2)
SELECT project_id, employee_id 
FROM Project 
JOIN Employee
USING (employee_id)
WHERE (project_id, experience_years) IN (SELECT project_id, MAX(experience_years)
                                         FROM Project
                                         JOIN Employee
                                         USING (employee_id)
                                         GROUP BY project_id);

"""

# 1098. Unpopular Books
1)
SELECT book_id, 
       name
FROM Books
WHERE available_from < '2019-05-23'
AND book_id NOT IN
            (SELECT book_id
             FROM Orders
             WHERE dispatch_date BETWEEN '2018-06-23' AND '2019-06-23'
             GROUP BY book_id
             Having sum(quantity) >= 10)
2)
SELECT b.book_id, b.name
FROM Books b
LEFT JOIN Orders o
ON b.book_id = o.book_id AND dispatch_date BETWEEN '2018-06-23' AND '2019-06-23'
WHERE DATEDIFF('2019-06-23', available_from) > 30
GROUP BY b.book_id, b.name
HAVING IFNULL(SUM(quantity), 0) < 10;

"""

# 1107. New Users Daily Count
1)
SELECT first_login AS login_date, COUNT(user_id) AS user_count
FROM (SELECT user_id, MIN(activity_date) as first_login
      FROM Traffic
      WHERE activity = 'login' 
      GROUP BY user_id) t
WHERE DATEDIFF('2019-06-30', first_login) <= 90
GROUP BY login_date;
2)
SELECT min_date AS login_date, COUNT(DISTINCT user_id) AS user_count
FROM (SELECT *, 
             MIN(activity_date) OVER (PARTITION BY user_id) AS min_date
      FROM Traffic
      WHERE activity = 'login') t
WHERE DATEDIFF('2019-06-30', min_date) <= 90
GROUP BY 1;

"""

# 1112. Highest Grade For Each Student
1)
SELECT student_id, MIN(course_id) AS course_id, grade
FROM Enrollments
WHERE (student_id, grade) IN (SELECT student_id, MAX(grade)
                              FROM Enrollments
                              GROUP BY student_id)
GROUP BY student_id, grade
ORDER BY 1;
2)
SELECT student_id, course_id, grade
FROM (SELECT *, 
      RANK() OVER (PARTITION BY student_id ORDER BY grade DESC, course_id ASC) AS rnk
      FROM Enrollments) t
WHERE rnk = 1;

"""

# 
