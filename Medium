# 177. Nth Highest Salary
1) https://leetcode.com/problems/nth-highest-salary/discuss/1013080/Mysql-%3A-Order-by-Limit
CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INT
BEGIN
SET N = N - 1;
  RETURN (
      # Write your MySQL query statement below.
      SELECT DISTINCT Salary
      FROM Employee 
      ORDER BY Salary DESC
      LIMIT 1 OFFSET N
  );
END
2)
CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INT
BEGIN
  RETURN (
      # Write your MySQL query statement below.
      SELECT DISTINCT Salary
      FROM (SELECT Salary, DENSE_RANK() OVER (ORDER BY Salary DESC) AS rnk
            FROM Employee) t
      WHERE N = rnk
  );
END

"""

# 178. Rank Scores
1)
SELECT Score AS score, DENSE_RANK() OVER (ORDER BY Score DESC) AS 'rank'
FROM Scores
2) https://leetcode.com/problems/rank-scores/discuss/456610/MySQL-Two-Simple-Solutions-and-Explanations-for-Beginners
SELECT S.Score, COUNT(S2.Score) AS 'Rank'
FROM Scores S, (SELECT DISTINCT Score FROM Scores) S2
WHERE S.Score<=S2.Score
GROUP BY S.Id 
ORDER BY S.Score DESC;

"""

# 180. Consecutive Numbers
1)
SELECT DISTINCT l2.Num AS ConsecutiveNums
FROM Logs l1, Logs l2, Logs l3
WHERE l2.Id - l1.Id = 1 AND l3.Id - l2.Id = 1
AND l1.Num = l2.Num AND l2.Num = l3.Num;
2)
select distinct Num as ConsecutiveNums
from Logs
where (Id + 1, Num) in (select * from Logs) and (Id + 2, Num) in (select * from Logs)
3) 
SELECT DISTINCT Num AS ConsecutiveNums
FROM (SELECT Id, Num,
      LAG(Num, 1) OVER (ORDER BY Id) AS Num_before,
      LEAD(Num, 1) OVER (ORDER BY Id) AS Num_after
      FROM Logs) t
WHERE Num = Num_before AND Num = Num_after;

"""

184. Department Highest Salary
1)
SELECT Department, Employee, Salary
FROM 
(SELECT d.Name AS Department, e.Name AS Employee, e.Salary,
        RANK() OVER (PARTITION BY d.Name ORDER BY e.Salary DESC) AS rnk
 FROM Employee e 
 JOIN Department d 
 ON e.DepartmentId = d.Id) t
WHERE rnk = 1;
2)
SELECT D.Name AS Department ,E.Name AS Employee ,E.Salary 
from Employee E
JOIN Department D 
ON E.DepartmentId = D.id 
WHERE (DepartmentId,Salary) in (SELECT DepartmentId,max(Salary) 
                                FROM Employee 
                                GROUP BY DepartmentId)
3)
select Department.Name as Department, e1.Name as Employee, Salary
from Employee e1, Department
where e1.DepartmentId = Department.Id 
and Salary >= ALL (select Salary from Employee e2 where e2.DepartmentId = e1.DepartmentId);
4)
SELECT dep.Name as Department, emp.Name as Employee, emp.Salary 
from Department dep, Employee emp 
where emp.DepartmentId=dep.Id 
and emp.Salary=(Select max(Salary) from Employee e2 where e2.DepartmentId=dep.Id)

"""

# 534. Game Play Analysis III
1)
SELECT player_id, 
       event_date, 
       SUM(games_played) OVER (PARTITION BY player_id ORDER BY event_date) AS games_played_so_far
FROM Activity;
2) exceed time limit
select player_id, 
       event_date, 
       (select sum(games_played) 
       from Activity 
       where player_id = a.player_id and event_date<=a.event_date) as "games_played_so_far"
from Activity a
3)
select a1.player_id, a1.event_date, sum(a2.games_played) as games_played_so_far
from Activity a1, Activity a2
where a1.player_id = a2.player_id and a2.event_date <= a1.event_date
group by a1.player_id, a1.event_date
order by a1.player_id, a1.event_date

"""

# 550. Game Play Analysis IV
1) https://leetcode.com/problems/game-play-analysis-iv/discuss/508062/MySQL-Without-JOIN-with-Explanation
SELECT ROUND(COUNT(DISTINCT player_id) / (SELECT COUNT(DISTINCT player_id) FROM Activity), 2) AS fraction
FROM activity
WHERE (player_id, SUBDATE(event_date, 1)) IN (SELECT player_id, MIN(event_date) 
                                              FROM Activity
                                              GROUP BY player_id)
2) https://leetcode.com/problems/game-play-analysis-iv/discuss/324851/MySQL-solution-with-STEP-BY-STEP-explanation
SELECT ROUND(SUM(CASE WHEN a.event_date + 1 = b.event_date THEN 1 ELSE 0 END)/COUNT(DISTINCT a.player_id), 2) AS fraction 
FROM (SELECT player_id, MIN(event_date) AS event_date
      FROM Activity 
      GROUP BY player_id) AS a 
JOIN Activity AS b 
ON a.player_id = b.player_id
3) https://leetcode.com/problems/game-play-analysis-iv/discuss/995878/Using-LEAD-Straight-solution
SELECT ROUND(COUNT(DISTINCT player_id) / (SELECT COUNT(DISTINCT player_id) FROM Activity), 2) AS fraction
FROM (SELECT player_id, 
      MIN(event_date) OVER (PARTITION BY player_id) AS first_date, 
      LEAD(event_date, 1) OVER (PARTITION BY player_id ORDER BY event_date) AS date_after
      FROM Activity) t
WHERE date_after - first_date = 1

"""

# 570. Managers with at Least 5 Direct Reports
1)
SELECT DISTINCT e.Name
FROM Employee e
JOIN (SELECT ManagerId, COUNT(Id) OVER (PARTITION BY ManagerId) AS num
      FROM Employee) t
ON t.ManagerId = e.Id
WHERE num >= 5
2)
SELECT Name
FROM Employee
WHERE Id IN (SELECT ManagerId
             FROM Employee
             GROUP BY ManagerId
             HAVING COUNT(Id) >= 5);
3)
SELECT e2.Name
FROM Employee e1, Employee e2
WHERE e1.ManagerId = e2.Id
GROUP BY e2.Id
HAVING COUNT(e1.Id) >= 5

"""

# 574. Winning Candidate
1)
SELECT c.Name
FROM Candidate c
JOIN (SELECT CandidateId, COUNT(*) AS num
      FROM Vote
      GROUP BY CandidateId
      ORDER BY num DESC
      LIMIT 1) t
ON c.id = t.CandidateId;
2)
SELECT c.Name
FROM Candidate c
JOIN (SELECT CandidateId, 
             COUNT(CandidateId) OVER (PARTITION BY CandidateId) AS num
      FROM Vote) t
ON c.id = t.CandidateId
ORDER BY num DESC
LIMIT 1;
3)
SELECT Name
FROM (SELECT CandidateId, RANK() OVER (ORDER BY COUNT(CandidateId) DESC) AS rnk
      FROM Vote
      GROUP BY CandidateId) t
JOIN Candidate
ON t.CandidateId = Candidate.id
WHERE rnk = 1 

"""

# 578. Get Highest Answer Rate Question

SELECT question_id AS survey_log
FROM survey_log
GROUP BY question_id
ORDER BY SUM(action = 'answer') / COUNT(*) DESC
LIMIT 1;

"""

# 580. Count Student Number in Departments
1)
SELECT dept_name, COUNT(student_id) AS student_number
FROM department
LEFT JOIN student 
USING (dept_id)
GROUP BY dept_name
ORDER BY 2 DESC, 1
2) https://leetcode.com/problems/count-student-number-in-departments/discuss/734641/MySQL%3A-Using-SUM(CASE-WHEN...)-instead-of-COUNT
SELECT dept_name, SUM(CASE WHEN s.dept_id THEN 1 ELSE 0 END) as student_number
FROM department d LEFT JOIN student s ON d.dept_id = s.dept_id
GROUP BY 1
ORDER BY 2 desc, 1

"""

# 585. Investments in 2016
1)
SELECT SUM(TIV_2016) AS TIV_2016
FROM insurance
WHERE TIV_2015 IN (SELECT TIV_2015
                   FROM insurance
                   GROUP BY TIV_2015
                   HAVING COUNT(TIV_2015) > 1)
AND (LAT, LON) IN (SELECT LAT, LON
                  FROM insurance
                  GROUP BY LAT, LON
                  HAVING COUNT(*) = 1)
2)
SELECT SUM(TIV_2016) AS TIV_2016
FROM (SELECT TIV_2016, 
             COUNT(TIV_2015) OVER (PARTITION BY TIV_2015) AS cnt2015,
             COUNT(*) OVER (PARTITION BY LAT, LON) AS cntloc
      FROM insurance) t
WHERE cnt2015 > 1 AND cntloc = 1 

"""

# 602. Friend Requests II: Who Has the Most Friends
1)
SELECT id1 AS id, COUNT(*) AS num
FROM (
    SELECT requester_id AS id1, accepter_id AS id2
    FROM request_accepted
    UNION 
    SELECT accepter_id AS id1, requester_id AS id2
    FROM request_accepted
    ) t
GROUP BY id1
ORDER BY num DESC
LIMIT 1;
2)
WITH t AS (SELECT accepter_id AS id, COUNT(requester_id) AS cnt
           FROM request_accepted 
           GROUP BY accepter_id
           UNION ALL
           SELECT requester_id AS id, COUNT(accepter_id) AS cnt
           FROM request_accepted
           GROUP BY requester_id)
SELECT id, SUM(cnt) AS num
FROM t 
GROUP BY id
ORDER BY num DESC
LIMIT 1;

"""

# 608. Tree Node
1) https://leetcode.com/problems/tree-node/discuss/219003/Need-help-!!-what's-wrong-with-my-code
SELECT id, CASE WHEN p_id IS NULL THEN 'Root'
                WHEN id NOT IN (SELECT DISTINCT p_id 
                                FROM tree
                                WHERE p_id IS NOT NULL) THEN 'Leaf'
                ELSE 'Inner' END AS Type
FROM tree
2) https://leetcode.com/problems/tree-node/discuss/104112/Solution-with-explanation%3A-CASE-%2B-LEFT-JOIN
SELECT DISTINCT t1.id, (
    CASE
    WHEN t1.p_id IS NULL  THEN 'Root'
    WHEN t1.p_id IS NOT NULL AND t2.id IS NOT NULL THEN 'Inner'
    WHEN t1.p_id IS NOT NULL AND t2.id IS NULL THEN 'Leaf'
    END
) AS Type 
FROM tree t1
LEFT JOIN tree t2
ON t1.id = t2.p_id
3)
select id,
case when p_id is null then 'Root'
when id in (select distinct p_id from tree) then 'Inner'
else 'Leaf'
end as 'Type'
from tree

"""

# 612. Shortest Distance in a Plane
1)
SELECT ROUND(MIN(SQRT(POWER(x1 - x2, 2) + POWER(y1 - y2, 2))), 2) AS shortest
FROM (SELECT p1.x AS x1, p2.x AS x2, p1.y AS y1, p2.y AS y2
      FROM point_2d p1
      CROSS JOIN point_2d p2
      WHERE (p1.x, p1.y) != (p2.x, p2.y)) t
2)
SELECT ROUND(MIN(SQRT(POWER(p1.x - p2.x, 2) + POWER(p1.y - p2.y, 2))), 2) AS shortest
FROM point_2d p1,point_2d p2
WHERE (p1.x, p1.y) != (p2.x, p2.y) 

"""

# 614. Second Degree Follower
1)
SELECT f1.follower, COUNT(DISTINCT f2.follower) AS num
FROM follow f1, follow f2
WHERE f1.follower = f2.followee
GROUP BY f1.follower
ORDER BY 1;
2)
SELECT followee AS follower, COUNT(DISTINCT follower) AS num
FROM follow
WHERE followee IN (SELECT DISTINCT follower
                   FROM follow)
GROUP BY followee
ORDER BY followee;

"""

# 626. Exchange Seats
1)
SELECT (CASE WHEN id % 2 = 0 THEN id - 1 
             WHEN id % 2 = 1 AND id != (SELECT COUNT(*) FROM seat) THEN id + 1
             ELSE id END) AS id,
        student
FROM seat 
ORDER BY id;
2)
SELECT id,
       IFNULL((CASE WHEN id % 2 = 1 THEN LEAD(student, 1) OVER (ORDER BY id)
             ELSE LAG(student, 1) OVER (ORDER BY id) END), student) AS student 
FROM seat 
ORDER BY id;
3)
SELECT id,
       CASE WHEN id % 2 = 0 THEN LAG(student) OVER (ORDER BY id)
            WHEN id % 2 = 1 AND id != (SELECT MAX(id) FROM seat) THEN LEAD(student) OVER (ORDER BY id)
            ELSE student END AS Student 
FROM seat 
ORDER BY id;

"""

# 1045. Customers Who Bought All Products

SELECT customer_id
FROM Customer
GROUP BY customer_id
HAVING COUNT(DISTINCT product_key) = (SELECT COUNT(*) FROM Product)

"""

# 1070. Product Sales Analysis III
1)
SELECT product_id, year AS first_year, quantity, price
FROM Sales
WHERE (product_id, year) IN (SELECT product_id, MIN(year) 
                             FROM Sales
                             GROUP BY product_id);
2)
SELECT product_id, year AS first_year, quantity, price
FROM (SELECT *, RANK() OVER (PARTITION BY product_id ORDER BY year) AS rnk
      FROM Sales) t
WHERE rnk = 1;

"""

# 1077. Project Employees III
1)
WITH t AS (SELECT project_id, 
                  employee_id,
                  RANK() OVER (PARTITION BY project_id ORDER BY experience_years DESC) AS rnk
           FROM Project
           JOIN Employee 
           USING (employee_id))

SELECT project_id, employee_id
FROM t
WHERE rnk = 1;
2)
SELECT project_id, employee_id 
FROM Project 
JOIN Employee
USING (employee_id)
WHERE (project_id, experience_years) IN (SELECT project_id, MAX(experience_years)
                                         FROM Project
                                         JOIN Employee
                                         USING (employee_id)
                                         GROUP BY project_id);

"""

# 1098. Unpopular Books
1)
SELECT book_id, 
       name
FROM Books
WHERE available_from < '2019-05-23'
AND book_id NOT IN
            (SELECT book_id
             FROM Orders
             WHERE dispatch_date BETWEEN '2018-06-23' AND '2019-06-23'
             GROUP BY book_id
             Having sum(quantity) >= 10)
2)
SELECT b.book_id, b.name
FROM Books b
LEFT JOIN Orders o
ON b.book_id = o.book_id AND dispatch_date BETWEEN '2018-06-23' AND '2019-06-23'
WHERE DATEDIFF('2019-06-23', available_from) > 30
GROUP BY b.book_id, b.name
HAVING IFNULL(SUM(quantity), 0) < 10;

"""

# 1107. New Users Daily Count
1)
SELECT first_login AS login_date, COUNT(user_id) AS user_count
FROM (SELECT user_id, MIN(activity_date) as first_login
      FROM Traffic
      WHERE activity = 'login' 
      GROUP BY user_id) t
WHERE DATEDIFF('2019-06-30', first_login) <= 90
GROUP BY login_date;
2)
SELECT min_date AS login_date, COUNT(DISTINCT user_id) AS user_count
FROM (SELECT *, 
             MIN(activity_date) OVER (PARTITION BY user_id) AS min_date
      FROM Traffic
      WHERE activity = 'login') t
WHERE DATEDIFF('2019-06-30', min_date) <= 90
GROUP BY 1;
3)
SELECT activity_date AS login_date, COUNT(DISTINCT user_id) AS user_count
FROM Traffic 
WHERE DATEDIFF('2019-06-30', activity_date) <= 90
AND (user_id, activity_date) IN (SELECT user_id, MIN(activity_date)
                                 FROM Traffic
                                 WHERE activity = 'login'
                                 GROUP BY user_id
                                 )
GROUP BY login_date;

"""

# 1112. Highest Grade For Each Student
1)
SELECT student_id, MIN(course_id) AS course_id, grade
FROM Enrollments
WHERE (student_id, grade) IN (SELECT student_id, MAX(grade)
                              FROM Enrollments
                              GROUP BY student_id)
GROUP BY student_id, grade
ORDER BY 1;
2)
SELECT student_id, course_id, grade
FROM (SELECT *, 
      RANK() OVER (PARTITION BY student_id ORDER BY grade DESC, course_id ASC) AS rnk
      FROM Enrollments) t
WHERE rnk = 1;

"""

# 1126. Active Businesses
1)
WITH t AS (SELECT event_type, AVG(occurences) AS avg_o
           FROM Events
           GROUP BY event_type)
SELECT business_id
FROM Events 
JOIN t 
ON t.event_type = events.event_type AND occurences > avg_o
GROUP BY business_id
HAVING COUNT(business_id) > 1 
2)
SELECT business_id
FROM (SELECT *, AVG(occurences) OVER (PARTITION BY event_type) AS avg_o
      FROM Events) t 
WHERE occurences > avg_o
GROUP BY business_id
HAVING COUNT(*) > 1;

"""

1132. Reported Posts II

WITH t AS (SELECT action_date, 100* COUNT(DISTINCT Removals.post_id) / COUNT(DISTINCT post_id) AS avg_r
           FROM Actions
           LEFT JOIN Removals 
           USING (post_id)
           WHERE extra = 'spam'
           GROUP BY action_date)
SELECT ROUND(AVG(avg_r), 2) AS average_daily_percent
FROM t 

"""

1149. Article Views II

SELECT DISTINCT viewer_id AS id
FROM Views
GROUP BY viewer_id, view_date
HAVING COUNT(DISTINCT article_id) > 1
ORDER BY id;

"""

1158. Market Analysis I
1)
SELECT user_id AS buyer_id, join_date, IFNULL(COUNT(order_id), 0) AS orders_in_2019
FROM Users
LEFT JOIN Orders
ON Users.user_id = Orders.buyer_id   #If you use 'where' then those who doesn't have 2019 sale won't be joined at all
AND YEAR(order_date) = 2019
GROUP BY user_id;
2)
WITH new AS (SELECT buyer_id, COUNT(order_id) AS orders_tot
             FROM Orders
             WHERE YEAR(order_date)=2019
             GROUP BY buyer_id)
SELECT U.user_id AS buyer_id, U.join_date , IFNULL(orders_tot,0) AS orders_in_2019
FROM Users AS U
LEFT JOIN new
ON U.user_id=new.buyer_id
3)
select u.user_id as buyer_id, join_date, sum(case when YEAR(order_date) = '2019' then 1 else 0 end) as orders_in_2019
from Users u left join Orders o on u.user_id = o.buyer_id
group by u.user_id

"""

1164. Product Price at a Given Date
1)
SELECT DISTINCT Products.product_id, IFNULL(t.new_price, 10) AS price
FROM (SELECT *, RANK() OVER (PARTITION BY product_id ORDER BY change_date DESC) AS rnk
      FROM Products
      WHERE change_date <= '2019-08-16') t 
RIGHT JOIN Products 
ON t.product_id = Products.product_id AND rnk = 1 
2)
SELECT DISTINCT p.product_id, IFNULL(temp.new_price, 10) AS price 
FROM (SELECT *
      FROM Products
      WHERE (product_id, change_date) IN (SELECT product_id, MAX(change_date)
                                          FROM Products
                                          WHERE change_date <= '2019-08-16'
                                          GROUP BY product_id)) temp
RIGHT JOIN Products p
USING (Product_id);

"""

1174. Immediate Food Delivery II
1)
WITH temp AS (
SELECT *, IF(order_date = customer_pref_delivery_date, 'immediate', 'scheduled') AS note
FROM Delivery
WHERE (customer_id, order_date) IN (SELECT customer_id, MIN(order_date)
                                    FROM Delivery
                                    GROUP BY customer_id))
SELECT ROUND(SUM(note = 'immediate') / COUNT(delivery_id) * 100, 2) AS immediate_percentage
FROM temp
2)
SELECT ROUND(SUM(order_date = customer_pref_delivery_date) / COUNT(delivery_id) * 100, 2) AS immediate_percentage
FROM Delivery
WHERE (customer_id, order_date) IN (SELECT customer_id, MIN(order_date)
                                    FROM Delivery
                                    GROUP BY customer_id)
                                    
"""

1193. Monthly Transactions I

SELECT DATE_FORMAT(trans_date, '%Y-%m') AS month,
       country,
       COUNT(id) AS trans_count,
       SUM(state = 'approved') AS approved_count,
       SUM(amount) AS trans_total_amount,
       SUM(IF(state = 'approved', amount, 0)) AS approved_total_amount
FROM Transactions
GROUP BY month, country;

"""

1204. Last Person to Fit in the Elevator
1)
SELECT q1.person_name
FROM Queue q1, Queue q2
WHERE q1.turn >= q2.turn
GROUP BY q1.turn
HAVING SUM(q2.weight) <= 1000
ORDER BY SUM(q2.weight) DESC
LIMIT 1
2)
SELECT person_name 
FROM (SELECT *, SUM(weight) OVER (ORDER BY turn) AS running_sum
      FROM Queue) t
WHERE running_sum <= 1000
ORDER BY running_sum DESC
LIMIT 1;

"""

1205. Monthly Transactions II
