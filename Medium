# 177. Nth Highest Salary
1) https://leetcode.com/problems/nth-highest-salary/discuss/1013080/Mysql-%3A-Order-by-Limit
CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INT
BEGIN
SET N = N - 1;
  RETURN (
      # Write your MySQL query statement below.
      SELECT DISTINCT Salary
      FROM Employee 
      ORDER BY Salary DESC
      LIMIT 1 OFFSET N
  );
END
2)
CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INT
BEGIN
  RETURN (
      # Write your MySQL query statement below.
      SELECT DISTINCT Salary
      FROM (SELECT Salary, DENSE_RANK() OVER (ORDER BY Salary DESC) AS rnk
            FROM Employee) t
      WHERE N = rnk
  );
END

"""

# 178. Rank Scores
1)
SELECT Score AS score, DENSE_RANK() OVER (ORDER BY Score DESC) AS 'rank'
FROM Scores
2) https://leetcode.com/problems/rank-scores/discuss/456610/MySQL-Two-Simple-Solutions-and-Explanations-for-Beginners
SELECT S.Score, COUNT(S2.Score) AS 'Rank'
FROM Scores S, (SELECT DISTINCT Score FROM Scores) S2
WHERE S.Score<=S2.Score
GROUP BY S.Id 
ORDER BY S.Score DESC;

"""

# 180. Consecutive Numbers
1)
SELECT DISTINCT l2.Num AS ConsecutiveNums
FROM Logs l1, Logs l2, Logs l3
WHERE l2.Id - l1.Id = 1 AND l3.Id - l2.Id = 1
AND l1.Num = l2.Num AND l2.Num = l3.Num;
2)
select distinct Num as ConsecutiveNums
from Logs
where (Id + 1, Num) in (select * from Logs) and (Id + 2, Num) in (select * from Logs)
3) 
SELECT DISTINCT Num AS ConsecutiveNums
FROM (SELECT Id, Num,
      LAG(Num, 1) OVER (ORDER BY Id) AS Num_before,
      LEAD(Num, 1) OVER (ORDER BY Id) AS Num_after
      FROM Logs) t
WHERE Num = Num_before AND Num = Num_after;

"""

184. Department Highest Salary
1)
SELECT Department, Employee, Salary
FROM 
(SELECT d.Name AS Department, e.Name AS Employee, e.Salary,
        RANK() OVER (PARTITION BY d.Name ORDER BY e.Salary DESC) AS rnk
 FROM Employee e 
 JOIN Department d 
 ON e.DepartmentId = d.Id) t
WHERE rnk = 1;
2)
SELECT D.Name AS Department ,E.Name AS Employee ,E.Salary 
from Employee E
JOIN Department D 
ON E.DepartmentId = D.id 
WHERE (DepartmentId,Salary) in (SELECT DepartmentId,max(Salary) 
                                FROM Employee 
                                GROUP BY DepartmentId)
3)
select Department.Name as Department, e1.Name as Employee, Salary
from Employee e1, Department
where e1.DepartmentId = Department.Id 
and Salary >= ALL (select Salary from Employee e2 where e2.DepartmentId = e1.DepartmentId);
4)
SELECT dep.Name as Department, emp.Name as Employee, emp.Salary 
from Department dep, Employee emp 
where emp.DepartmentId=dep.Id 
and emp.Salary=(Select max(Salary) from Employee e2 where e2.DepartmentId=dep.Id)

"""

# 534. Game Play Analysis III
1)
SELECT player_id, 
       event_date, 
       SUM(games_played) OVER (PARTITION BY player_id ORDER BY event_date) AS games_played_so_far
FROM Activity;
2) exceed time limit
select player_id, 
       event_date, 
       (select sum(games_played) 
       from Activity 
       where player_id = a.player_id and event_date<=a.event_date) as "games_played_so_far"
from Activity a
3)
select a1.player_id, a1.event_date, sum(a2.games_played) as games_played_so_far
from Activity a1, Activity a2
where a1.player_id = a2.player_id and a2.event_date <= a1.event_date
group by a1.player_id, a1.event_date
order by a1.player_id, a1.event_date

"""

# 550. Game Play Analysis IV
1) https://leetcode.com/problems/game-play-analysis-iv/discuss/508062/MySQL-Without-JOIN-with-Explanation
SELECT ROUND(COUNT(DISTINCT player_id) / (SELECT COUNT(DISTINCT player_id) FROM Activity), 2) AS fraction
FROM activity
WHERE (player_id, SUBDATE(event_date, 1)) IN (SELECT player_id, MIN(event_date) 
                                              FROM Activity
                                              GROUP BY player_id)
2) https://leetcode.com/problems/game-play-analysis-iv/discuss/324851/MySQL-solution-with-STEP-BY-STEP-explanation
SELECT ROUND(SUM(CASE WHEN a.event_date + 1 = b.event_date THEN 1 ELSE 0 END)/COUNT(DISTINCT a.player_id), 2) AS fraction 
FROM (SELECT player_id, MIN(event_date) AS event_date
      FROM Activity 
      GROUP BY player_id) AS a 
JOIN Activity AS b 
ON a.player_id = b.player_id
3) https://leetcode.com/problems/game-play-analysis-iv/discuss/995878/Using-LEAD-Straight-solution
SELECT ROUND(COUNT(DISTINCT player_id) / (SELECT COUNT(DISTINCT player_id) FROM Activity), 2) AS fraction
FROM (SELECT player_id, 
      MIN(event_date) OVER (PARTITION BY player_id) AS first_date, 
      LEAD(event_date, 1) OVER (PARTITION BY player_id ORDER BY event_date) AS date_after
      FROM Activity) t
WHERE date_after - first_date = 1

"""

# 570. Managers with at Least 5 Direct Reports
1)
SELECT DISTINCT e.Name
FROM Employee e
JOIN (SELECT ManagerId, COUNT(Id) OVER (PARTITION BY ManagerId) AS num
      FROM Employee) t
ON t.ManagerId = e.Id
WHERE num >= 5
2)
SELECT Name
FROM Employee
WHERE Id IN (SELECT ManagerId
             FROM Employee
             GROUP BY ManagerId
             HAVING COUNT(Id) >= 5);
3)
SELECT e2.Name
FROM Employee e1, Employee e2
WHERE e1.ManagerId = e2.Id
GROUP BY e2.Id
HAVING COUNT(e1.Id) >= 5

"""

# 574. Winning Candidate
1)
SELECT c.Name
FROM Candidate c
JOIN (SELECT CandidateId, COUNT(*) AS num
      FROM Vote
      GROUP BY CandidateId
      ORDER BY num DESC
      LIMIT 1) t
ON c.id = t.CandidateId;
2)
SELECT c.Name
FROM Candidate c
JOIN (SELECT CandidateId, 
             COUNT(CandidateId) OVER (PARTITION BY CandidateId) AS num
      FROM Vote) t
ON c.id = t.CandidateId
ORDER BY num DESC
LIMIT 1;
3)
SELECT Name
FROM (SELECT CandidateId, RANK() OVER (ORDER BY COUNT(CandidateId) DESC) AS rnk
      FROM Vote
      GROUP BY CandidateId) t
JOIN Candidate
ON t.CandidateId = Candidate.id
WHERE rnk = 1 

"""

# 578. Get Highest Answer Rate Question

SELECT question_id AS survey_log
FROM survey_log
GROUP BY question_id
ORDER BY SUM(action = 'answer') / COUNT(*) DESC
LIMIT 1;

"""

# 580. Count Student Number in Departments
1)
SELECT dept_name, COUNT(student_id) AS student_number
FROM department
LEFT JOIN student 
USING (dept_id)
GROUP BY dept_name
ORDER BY 2 DESC, 1
2) https://leetcode.com/problems/count-student-number-in-departments/discuss/734641/MySQL%3A-Using-SUM(CASE-WHEN...)-instead-of-COUNT
SELECT dept_name, SUM(CASE WHEN s.dept_id THEN 1 ELSE 0 END) as student_number
FROM department d LEFT JOIN student s ON d.dept_id = s.dept_id
GROUP BY 1
ORDER BY 2 desc, 1

"""

# 585. Investments in 2016
1)
SELECT SUM(TIV_2016) AS TIV_2016
FROM insurance
WHERE TIV_2015 IN (SELECT TIV_2015
                   FROM insurance
                   GROUP BY TIV_2015
                   HAVING COUNT(TIV_2015) > 1)
AND (LAT, LON) IN (SELECT LAT, LON
                  FROM insurance
                  GROUP BY LAT, LON
                  HAVING COUNT(*) = 1)
2)
SELECT SUM(TIV_2016) AS TIV_2016
FROM (SELECT TIV_2016, 
             COUNT(TIV_2015) OVER (PARTITION BY TIV_2015) AS cnt2015,
             COUNT(*) OVER (PARTITION BY LAT, LON) AS cntloc
      FROM insurance) t
WHERE cnt2015 > 1 AND cntloc = 1 

"""

# 602. Friend Requests II: Who Has the Most Friends
1)
SELECT id1 AS id, COUNT(*) AS num
FROM (
    SELECT requester_id AS id1, accepter_id AS id2
    FROM request_accepted
    UNION 
    SELECT accepter_id AS id1, requester_id AS id2
    FROM request_accepted
    ) t
GROUP BY id1
ORDER BY num DESC
LIMIT 1;
2)
WITH t AS (SELECT accepter_id AS id, COUNT(requester_id) AS cnt
           FROM request_accepted 
           GROUP BY accepter_id
           UNION ALL
           SELECT requester_id AS id, COUNT(accepter_id) AS cnt
           FROM request_accepted
           GROUP BY requester_id)
SELECT id, SUM(cnt) AS num
FROM t 
GROUP BY id
ORDER BY num DESC
LIMIT 1;

"""

# 608. Tree Node
1) https://leetcode.com/problems/tree-node/discuss/219003/Need-help-!!-what's-wrong-with-my-code
SELECT id, CASE WHEN p_id IS NULL THEN 'Root'
                WHEN id NOT IN (SELECT DISTINCT p_id 
                                FROM tree
                                WHERE p_id IS NOT NULL) THEN 'Leaf'
                ELSE 'Inner' END AS Type
FROM tree
2) https://leetcode.com/problems/tree-node/discuss/104112/Solution-with-explanation%3A-CASE-%2B-LEFT-JOIN
SELECT DISTINCT t1.id, (
    CASE
    WHEN t1.p_id IS NULL  THEN 'Root'
    WHEN t1.p_id IS NOT NULL AND t2.id IS NOT NULL THEN 'Inner'
    WHEN t1.p_id IS NOT NULL AND t2.id IS NULL THEN 'Leaf'
    END
) AS Type 
FROM tree t1
LEFT JOIN tree t2
ON t1.id = t2.p_id
3)
select id,
case when p_id is null then 'Root'
when id in (select distinct p_id from tree) then 'Inner'
else 'Leaf'
end as 'Type'
from tree

"""

# 612. Shortest Distance in a Plane
1)
SELECT ROUND(MIN(SQRT(POWER(x1 - x2, 2) + POWER(y1 - y2, 2))), 2) AS shortest
FROM (SELECT p1.x AS x1, p2.x AS x2, p1.y AS y1, p2.y AS y2
      FROM point_2d p1
      CROSS JOIN point_2d p2
      WHERE (p1.x, p1.y) != (p2.x, p2.y)) t
2)
SELECT ROUND(MIN(SQRT(POWER(p1.x - p2.x, 2) + POWER(p1.y - p2.y, 2))), 2) AS shortest
FROM point_2d p1,point_2d p2
WHERE (p1.x, p1.y) != (p2.x, p2.y) 

"""

# 614. Second Degree Follower
1)
SELECT f1.follower, COUNT(DISTINCT f2.follower) AS num
FROM follow f1, follow f2
WHERE f1.follower = f2.followee
GROUP BY f1.follower
ORDER BY 1;
2)
SELECT followee AS follower, COUNT(DISTINCT follower) AS num
FROM follow
WHERE followee IN (SELECT DISTINCT follower
                   FROM follow)
GROUP BY followee
ORDER BY followee;

"""

# 626. Exchange Seats
1)
SELECT (CASE WHEN id % 2 = 0 THEN id - 1 
             WHEN id % 2 = 1 AND id != (SELECT COUNT(*) FROM seat) THEN id + 1
             ELSE id END) AS id,
        student
FROM seat 
ORDER BY id;
2)
SELECT id,
       IFNULL((CASE WHEN id % 2 = 1 THEN LEAD(student, 1) OVER (ORDER BY id)
             ELSE LAG(student, 1) OVER (ORDER BY id) END), student) AS student 
FROM seat 
ORDER BY id;
3)
SELECT id,
       CASE WHEN id % 2 = 0 THEN LAG(student) OVER (ORDER BY id)
            WHEN id % 2 = 1 AND id != (SELECT MAX(id) FROM seat) THEN LEAD(student) OVER (ORDER BY id)
            ELSE student END AS Student 
FROM seat 
ORDER BY id;

"""

# 1045. Customers Who Bought All Products

SELECT customer_id
FROM Customer
GROUP BY customer_id
HAVING COUNT(DISTINCT product_key) = (SELECT COUNT(*) FROM Product)

"""

# 1070. Product Sales Analysis III
1)
SELECT product_id, year AS first_year, quantity, price
FROM Sales
WHERE (product_id, year) IN (SELECT product_id, MIN(year) 
                             FROM Sales
                             GROUP BY product_id);
2)
SELECT product_id, year AS first_year, quantity, price
FROM (SELECT *, RANK() OVER (PARTITION BY product_id ORDER BY year) AS rnk
      FROM Sales) t
WHERE rnk = 1;

"""

# 1077. Project Employees III
1)
WITH t AS (SELECT project_id, 
                  employee_id,
                  RANK() OVER (PARTITION BY project_id ORDER BY experience_years DESC) AS rnk
           FROM Project
           JOIN Employee 
           USING (employee_id))

SELECT project_id, employee_id
FROM t
WHERE rnk = 1;
2)
SELECT project_id, employee_id 
FROM Project 
JOIN Employee
USING (employee_id)
WHERE (project_id, experience_years) IN (SELECT project_id, MAX(experience_years)
                                         FROM Project
                                         JOIN Employee
                                         USING (employee_id)
                                         GROUP BY project_id);

"""

# 1098. Unpopular Books
1)
SELECT book_id, 
       name
FROM Books
WHERE available_from < '2019-05-23'
AND book_id NOT IN
            (SELECT book_id
             FROM Orders
             WHERE dispatch_date BETWEEN '2018-06-23' AND '2019-06-23'
             GROUP BY book_id
             Having sum(quantity) >= 10)
2)
SELECT b.book_id, b.name
FROM Books b
LEFT JOIN Orders o
ON b.book_id = o.book_id AND dispatch_date BETWEEN '2018-06-23' AND '2019-06-23'
WHERE DATEDIFF('2019-06-23', available_from) > 30
GROUP BY b.book_id, b.name
HAVING IFNULL(SUM(quantity), 0) < 10;

"""

# 1107. New Users Daily Count
1)
SELECT first_login AS login_date, COUNT(user_id) AS user_count
FROM (SELECT user_id, MIN(activity_date) as first_login
      FROM Traffic
      WHERE activity = 'login' 
      GROUP BY user_id) t
WHERE DATEDIFF('2019-06-30', first_login) <= 90
GROUP BY login_date;
2)
SELECT min_date AS login_date, COUNT(DISTINCT user_id) AS user_count
FROM (SELECT *, 
             MIN(activity_date) OVER (PARTITION BY user_id) AS min_date
      FROM Traffic
      WHERE activity = 'login') t
WHERE DATEDIFF('2019-06-30', min_date) <= 90
GROUP BY 1;
3)
SELECT activity_date AS login_date, COUNT(DISTINCT user_id) AS user_count
FROM Traffic 
WHERE DATEDIFF('2019-06-30', activity_date) <= 90
AND (user_id, activity_date) IN (SELECT user_id, MIN(activity_date)
                                 FROM Traffic
                                 WHERE activity = 'login'
                                 GROUP BY user_id
                                 )
GROUP BY login_date;

"""

# 1112. Highest Grade For Each Student
1)
SELECT student_id, MIN(course_id) AS course_id, grade
FROM Enrollments
WHERE (student_id, grade) IN (SELECT student_id, MAX(grade)
                              FROM Enrollments
                              GROUP BY student_id)
GROUP BY student_id, grade
ORDER BY 1;
2)
SELECT student_id, course_id, grade
FROM (SELECT *, 
      RANK() OVER (PARTITION BY student_id ORDER BY grade DESC, course_id ASC) AS rnk
      FROM Enrollments) t
WHERE rnk = 1;

"""

# 1126. Active Businesses
1)
WITH t AS (SELECT event_type, AVG(occurences) AS avg_o
           FROM Events
           GROUP BY event_type)
SELECT business_id
FROM Events 
JOIN t 
ON t.event_type = events.event_type AND occurences > avg_o
GROUP BY business_id
HAVING COUNT(business_id) > 1 
2)
SELECT business_id
FROM (SELECT *, AVG(occurences) OVER (PARTITION BY event_type) AS avg_o
      FROM Events) t 
WHERE occurences > avg_o
GROUP BY business_id
HAVING COUNT(*) > 1;

"""

1132. Reported Posts II

WITH t AS (SELECT action_date, 100* COUNT(DISTINCT Removals.post_id) / COUNT(DISTINCT post_id) AS avg_r
           FROM Actions
           LEFT JOIN Removals 
           USING (post_id)
           WHERE extra = 'spam'
           GROUP BY action_date)
SELECT ROUND(AVG(avg_r), 2) AS average_daily_percent
FROM t 

"""

1149. Article Views II

SELECT DISTINCT viewer_id AS id
FROM Views
GROUP BY viewer_id, view_date
HAVING COUNT(DISTINCT article_id) > 1
ORDER BY id;

"""

1158. Market Analysis I
1)
SELECT user_id AS buyer_id, join_date, IFNULL(COUNT(order_id), 0) AS orders_in_2019
FROM Users
LEFT JOIN Orders
ON Users.user_id = Orders.buyer_id   #If you use 'where' then those who doesn't have 2019 sale won't be joined at all
AND YEAR(order_date) = 2019
GROUP BY user_id;
2)
WITH new AS (SELECT buyer_id, COUNT(order_id) AS orders_tot
             FROM Orders
             WHERE YEAR(order_date)=2019
             GROUP BY buyer_id)
SELECT U.user_id AS buyer_id, U.join_date , IFNULL(orders_tot,0) AS orders_in_2019
FROM Users AS U
LEFT JOIN new
ON U.user_id=new.buyer_id
3)
select u.user_id as buyer_id, join_date, sum(case when YEAR(order_date) = '2019' then 1 else 0 end) as orders_in_2019
from Users u left join Orders o on u.user_id = o.buyer_id
group by u.user_id

"""

1164. Product Price at a Given Date
1)
SELECT DISTINCT Products.product_id, IFNULL(t.new_price, 10) AS price
FROM (SELECT *, RANK() OVER (PARTITION BY product_id ORDER BY change_date DESC) AS rnk
      FROM Products
      WHERE change_date <= '2019-08-16') t 
RIGHT JOIN Products 
ON t.product_id = Products.product_id AND rnk = 1 
2)
SELECT DISTINCT p.product_id, IFNULL(temp.new_price, 10) AS price 
FROM (SELECT *
      FROM Products
      WHERE (product_id, change_date) IN (SELECT product_id, MAX(change_date)
                                          FROM Products
                                          WHERE change_date <= '2019-08-16'
                                          GROUP BY product_id)) temp
RIGHT JOIN Products p
USING (Product_id);

"""

1174. Immediate Food Delivery II
1)
WITH temp AS (
SELECT *, IF(order_date = customer_pref_delivery_date, 'immediate', 'scheduled') AS note
FROM Delivery
WHERE (customer_id, order_date) IN (SELECT customer_id, MIN(order_date)
                                    FROM Delivery
                                    GROUP BY customer_id))
SELECT ROUND(SUM(note = 'immediate') / COUNT(delivery_id) * 100, 2) AS immediate_percentage
FROM temp
2)
SELECT ROUND(SUM(order_date = customer_pref_delivery_date) / COUNT(delivery_id) * 100, 2) AS immediate_percentage
FROM Delivery
WHERE (customer_id, order_date) IN (SELECT customer_id, MIN(order_date)
                                    FROM Delivery
                                    GROUP BY customer_id)
                                    
"""

1193. Monthly Transactions I

SELECT DATE_FORMAT(trans_date, '%Y-%m') AS month,
       country,
       COUNT(id) AS trans_count,
       SUM(state = 'approved') AS approved_count,
       SUM(amount) AS trans_total_amount,
       SUM(IF(state = 'approved', amount, 0)) AS approved_total_amount
FROM Transactions
GROUP BY month, country;

"""

1204. Last Person to Fit in the Elevator
1)
SELECT q1.person_name
FROM Queue q1, Queue q2
WHERE q1.turn >= q2.turn
GROUP BY q1.turn
HAVING SUM(q2.weight) <= 1000
ORDER BY SUM(q2.weight) DESC
LIMIT 1
2)
SELECT person_name 
FROM (SELECT *, SUM(weight) OVER (ORDER BY turn) AS running_sum
      FROM Queue) t
WHERE running_sum <= 1000
ORDER BY running_sum DESC
LIMIT 1;

"""

1205. Monthly Transactions II
1)
WITH t AS (
    SELECT c.trans_id, DATE_FORMAT(c.trans_date, '%Y-%m') AS month, country, 'chargeback' AS state, amount
    FROM Chargebacks c  
    JOIN Transactions t  
    ON c.trans_id = t.id
    UNION
    SELECT t.id, DATE_FORMAT(t.trans_date, '%Y-%m') AS month, country, state, amount 
    FROM Transactions t)
    
SELECT month, country, SUM(state = 'approved') AS approved_count, SUM(IF(state = 'approved', amount, 0)) AS approved_amount, SUM(state = 'chargeback') AS chargeback_count, SUM(IF(state = 'chargeback', amount, 0)) AS chargeback_amount
FROM t 
GROUP BY month, country
HAVING approved_count + approved_amount + chargeback_count + chargeback_amount != 0 ;
2)
WITH t AS (
    SELECT LEFT(c.trans_date, 7) AS month, country, "chargeback" AS state, amount
    FROM chargebacks c
    JOIN transactions t ON c.trans_id = t.id
    UNION ALL
    SELECT LEFT(trans_date, 7) AS month, country, state, amount
    FROM transactions t
    WHERE state = "approved"    # If we do not filter out declined transactions at the beginning, we may get entries that have 0 for all four columns, which shouldn't be included in the result.
)
SELECT month, 
       country, 
       SUM(state = "approved") AS approved_count, 
       SUM(IF(state = 'approved', amount, 0)) AS approved_amount, 
       SUM(state = "chargeback") AS chargeback_count, 
       SUM(IF(state = "chargeback", amount, 0)) AS chargeback_amount
FROM t
GROUP BY month, country;

"""

1212. Team Scores in Football Tournament
1)
WITH temp AS (
    SELECT host_team AS team_id, 
    SUM(CASE WHEN host_goals > guest_goals THEN 3
             WHEN host_goals = guest_goals THEN 1
             ELSE 0 END) AS points
    FROM Matches 
    GROUP BY host_team
    UNION ALL
    SELECT guest_team AS team_id, 
           SUM(CASE WHEN guest_goals > host_goals THEN 3
           WHEN guest_goals = host_goals THEN 1
           ELSE 0 END) AS points
    FROM Matches
    GROUP BY guest_team
)
    
SELECT t.team_id, team_name, IFNULL(SUM(points), 0) AS num_points
FROM Teams t 
LEFT JOIN temp
USING (team_id)
GROUP BY 1, 2
ORDER BY num_points DESC, 1;
2)
SELECT team_id, team_name,
SUM(
    CASE WHEN team_id = host_team AND host_goals > guest_goals THEN 3
         WHEN team_id = guest_team AND guest_goals > host_goals THEN 3
         WHEN host_goals = guest_goals THEN 1
         ELSE 0
    END          
) AS "num_points"
FROM Teams t
LEFT JOIN Matches m ON t.team_id = m.host_team OR t.team_id = m.guest_team
GROUP BY team_id, team_name
ORDER BY num_points DESC, team_id;
3)
select team_id, team_name,
sum(case when team_id = host_team and host_goals > guest_goals then 3 else 0 end) +
sum(case when team_id = guest_team and guest_goals > host_goals then 3 else 0 end) +
sum(case when team_id = host_team and host_goals = guest_goals then 1 else 0 end) +
sum(case when team_id = guest_team and host_goals = guest_goals then 1 else 0 end)
as 'num_points'
from teams
left join matches
on team_id = host_team
or team_id = guest_team
group by team_id, team_name
order by num_points desc, team_id asc;

"""

1264. Page Recommendations
1)
SELECT DISTINCT page_id AS recommended_page
FROM Friendship f
JOIN Likes l
ON f.user1_id = l.user_id OR f.user2_id = l.user_id
WHERE (f.user1_id = 1 or f.user2_id = 1) 
AND page_id NOT IN (SELECT DISTINCT page_id
                      FROM Likes
                      WHERE user_id = 1)                   
2)
WITH t AS (
    SELECT user1_id, user2_id AS user_id
    FROM Friendship
    WHERE user1_id = 1
    UNION
    SELECT user2_id, user1_id AS user_id
    FROM Friendship
    WHERE user2_id = 1
)
SELECT DISTINCT page_id AS recommended_page
FROM t
JOIN Likes l
USINg (user_id)
WHERE page_id NOT IN (SELECT DISTINCT page_id
                      FROM Likes
                      WHERE user_id = 1)
3)
SELECT DISTINCT page_id as recommended_page
FROM (
    SELECT CASE WHEN user1_id = 1 then user2_id
                WHEN user2_id = 1 then user1_id
                END AS user_id
FROM Friendship) t
JOIN Likes l
on t.user_id = l.user_id
WHERE page_id NOT IN (SELECT DISTINCT page_id 
                      FROM Likes 
                      WHERE user_id = 1);

"""

1270. All People Report to the Given Manager
1)
SELECT e1.employee_id
FROM Employees e1
JOIN Employees e2
ON e1.manager_id = e2.employee_id
JOIN Employees e3
ON e2.manager_id = e3.employee_id
WHERE e3.manager_id = 1 AND e1.employee_id != 1
  
Alternative:
 SELECT e1.employee_id
FROM Employees e1,
     Employees e2,
     Employees e3
WHERE e1.manager_id = e2.employee_id
  AND e2.manager_id = e3.employee_id
  AND e3.manager_id = 1 
  AND e1.employee_id != 1
2)
with recursive cte1(id,n) as
(
    select employee_id as id, 1 as n
    from employees
    where manager_id=1 and employee_id!=1
    union
    select employee_id as id,n+1 as n
    from employees, cte1
    where manager_id=cte1.id and n+1<4
)
select id as employee_id 
from cte1
3)
SELECT a.employee_id as EMPLOYEE_ID 
FROM Employees as a      # those whose boss is 1
WHERE a.employee_id!=1 AND a.manager_id=1
UNION
SELECT b.employee_id 
FROM Employees as b      #those whose boss' boss is 1
WHERE b.manager_id IN (SELECT a.employee_id 
                       FROM Employees as a
                       WHERE a.employee_id!=1 AND a.manager_id=1)
UNION
SELECT c.employee_id FROM Employees as c      #those whose boss' boss' boss is 1
WHERE c.manager_id IN (SELECT b.employee_id 
                       FROM Employees as b
                       WHERE b.manager_id IN (SELECT a.employee_id 
                                              FROM Employees as a
                                              WHERE a.employee_id!=1 AND a.manager_id=1))
ORDER BY EMPLOYEE_ID;

"""

1285. Find the Start and End Number of Continuous Ranges

# the difference of (log_id - num) will change whenever a log_id is skipped. The rows with same difference (log_id - num), 
should be a continuous series. Then we just need to find the min, and max for that series as start/ end id. 
log_id, num, difference
1, 1, 0
2, 2, 0
3, 3, 0
7, 4, 3
8, 5, 3
10, 6, 4

SELECT MIN(log_id) as start_id, MAX(log_id) AS end_id
FROM (SELECT log_id, 
             ROW_NUMBER() OVER(ORDER BY log_id) as num
      FROM Logs) a
GROUP BY log_id - num;

"""

1308. Running Total for Different Genders
1)
SELECT gender, day, SUM(score_points) OVER (PARTITION BY gender ORDER BY day) AS total
FROM Scores 
ORDER BY gender, day;
2)
SELECT s1.gender, s1.day, SUM(s2.score_points) AS total
FROM Scores AS s1,
     Scores AS s2
WHERE s1.gender = s2.gender AND s2.day <= s1.day
GROUP BY s1.gender, s1.day
ORDER BY s1.gender, s1.day

"""

1321. Restaurant Growth
1)
WITH temp AS (
    SELECT visited_on, 
           SUM(amount) OVER(ORDER BY visited_on ROWS BETWEEN 6 PRECEDING AND CURRENT ROW) AS amount,
           ROUND(AVG(amount) OVER(ORDER BY visited_on ROWS BETWEEN 6 PRECEDING AND CURRENT ROW), 2) AS average_amount
    FROM (SELECT visited_on, SUM(amount) AS amount
          FROM Customer
          GROUP BY visited_on) t
)
SELECT *
FROM temp 
WHERE DATE_SUB(visited_on, INTERVAL 6 DAY) IN (SELECT DISTINCT visited_on FROM Customer);

2) https://leetcode.com/problems/restaurant-growth/discuss/1005697/MySQL-Easy-to-Read-and-Faster-Than-85-(w-Window-Function)
with sum_table as (
select distinct visited_on,
sum(amount) over (order by visited_on range between interval 6 day preceding and current row) as amount,
-- note that we use range to get the preceding 6 days
dense_rank() over (order by visited_on) as days
-- we need to remove the first 6 days from the output, note that dense_rank() is used to avoid gap in rank
from Customer
)
select visited_on, amount, round(amount/7,2) as average_amount
from sum_table
where days >= 7;

3) fastest method
SELECT b.visited_on, 
       SUM(a.amount) AS amount, 
       ROUND(SUM(a.amount)/7,2) AS average_amount
FROM Customer a, 
     (SELECT DISTINCT visited_on 
      FROM Customer) b
WHERE DATEDIFF(b.visited_on, a.visited_on) BETWEEN 0 AND 6
GROUP BY b.visited_on
HAVING COUNT(DISTINCT a.visited_on) = 7

"""

1341. Movie Rating
1)
WITH t1 AS (SELECT name, 
                   RANK() OVER (ORDER BY COUNT(DISTINCT movie_id) DESC, name) AS rnk
            FROM Movie_Rating 
            JOIN Users USING (user_id)
            GROUP BY user_id),
     t2 AS (SELECT title,
                   RANK() OVER (ORDER BY AVG(rating) DESC, title) AS rnk
            FROM Movies
            JOIN Movie_Rating USING (movie_id)
            WHERE LEFT(created_at, 7) = '2020-02'
            GROUP BY title)    
SELECT name AS results
FROM t1
WHERE t1.rnk = 1
UNION
SELECT title As results
FROM t2
WHERE t2.rnk = 1;

2) https://leetcode.com/problems/movie-rating/discuss/502651/MySQL-solution-using-UNION-SELECT-and-GROUP-BY
SELECT user_name as results FROM
(
    SELECT b.name as user_name,COUNT(*) as counts FROM Movie_rating as a
    JOIN Users as b
    ON a.user_id=b.user_id
    GROUP BY a.user_id
    ORDER BY counts DESC,user_name ASC LIMIT 1
) first_query #query for the person who rates the greatest number of movies
UNION
SELECT movie_name as results FROM
(
    SELECT d.title as movie_name,AVG(c.rating) as grade FROM Movie_rating as c
    JOIN Movies as d
    ON c.movie_id=d.movie_id
    WHERE SUBSTR(c.created_at,1,7)="2020-02"
    GROUP BY c.movie_id
    ORDER BY grade DESC,movie_name ASC LIMIT 1
) second_query; #query for the movie with the highest average rating in February

"""

1355. Activity Participants
1)
WITH t AS(
    SELECT activity,
           RANK() OVER (ORDER BY COUNT(id) DESC) AS rnk1,
           RANK() OVER (ORDER BY COUNT(id)) AS rnk2
    FROM Friends
    GROUP BY activity)
SELECT activity
FROM t 
WHERE rnk1 != 1 AND rnk2 != 1
2)
SELECT activity 
FROM friends
GROUP BY activity
HAVING COUNT(id) > (SELECT COUNT(id) 
                    FROM friends 
                    GROUP BY activity 
                    ORDER BY 1 
                    LIMIT 1)
AND COUNT(id) < (SELECT COUNT(id) 
                 FROM friends 
                 GROUP BY activity 
                 ORDER BY 1 DESC 
                 LIMIT 1); 
                 
"""                 

1364. Number of Trusted Contacts of a Customer
1)
WITH temp AS (
    SELECT customer_id, 
           customer_name, 
           COUNT(contact_name) AS contacts_cnt, 
           SUM(CASE WHEN contact_email IN (SELECT email FROM Customers) THEN 1 ELSE 0 END) AS trusted_contacts_cnt
    FROM Contacts c1
    RIGHT JOIN Customers c2
    ON c1.user_id = c2.customer_id
    GROUP BY 1, 2)
SELECT invoice_id, customer_name, price, contacts_cnt, trusted_contacts_cnt
FROM temp
RIGHT JOIN invoices 
ON temp.customer_id = Invoices.user_id
ORDER BY invoice_id;

2)https://leetcode.com/problems/number-of-trusted-contacts-of-a-customer/discuss/562342/Easy-MS-SQL
select
    i.invoice_id,
    c.customer_name,
    i.price,
    count(con.user_id) as contacts_cnt,
    count(c2.email) as trusted_contacts_cnt
from invoices i
join customers c on c.customer_id = i.user_id
left join contacts con on con.user_id = c.customer_id
left join customers c2 on c2.email = con.contact_email
group by i.invoice_id, c.customer_name, i.price
order by i.invoice_id;

3) https://leetcode.com/problems/number-of-trusted-contacts-of-a-customer/discuss/900767/MySQL-with-CTE-simpler-than-most-of-the-answers-and-beats-98
WITH cte AS
(SELECT user_id, count(contact_email) contacts_cnt, SUM(contact_email IN (SELECT email FROM Customers)) trusted_contacts_cnt
FROM Contacts
GROUP BY 1)
SELECT i.invoice_id, c.customer_name, i.price, IFNULL(contacts_cnt, 0) contacts_cnt, IFNULL(trusted_contacts_cnt, 0) trusted_contacts_cnt
FROM Invoices i
LEFT JOIN Customers c
ON i.user_id = c.customer_id
LEFT JOIN cte
ON i.user_id = cte.user_id
ORDER BY 1;

""""

1393. Capital Gain/Loss
SELECT stock_name, 
       SUM(IF(operation = 'Buy', - price, price)) AS capital_gain_loss
FROM Stocks
GROUP BY stock_name; 

"""

1398. Customers Who Bought Products A and B but Not C
1)
SELECT *
FROM Customers 
WHERE customer_id IN (SELECT customer_id
                    FROM Orders
                    GROUP BY customer_id
                    HAVING SUM(product_name = 'A') > 0
                    AND SUM(product_name = 'B') > 0
                    AND SUM(product_name = 'C') = 0)
2)
select a.customer_id, a.customer_name
from customers a , orders b
where a.customer_id  = b.customer_id
group by a.customer_id
having sum(b.product_name="A") >0 and sum(b.product_name="B") > 0 and sum(b.product_name="C")=0

3) https://leetcode.com/problems/customers-who-bought-products-a-and-b-but-not-c/discuss/563827/100-Left-Outer-Join
SELECT c.customer_id, c.customer_name
FROM Customers c
JOIN Orders a ON a.customer_id = c.customer_id AND a.product_name = "A"
JOIN Orders b ON b.customer_id = c.customer_id AND b.product_name = "B"
LEFT OUTER JOIN Orders o on o.customer_id = c.customer_id AND o.product_name = "C"
WHERE o.order_id IS NULL;

"""

1421. NPV Queries

SELECT q.id, q.year, IFNULL(n.npv, 0) AS npv
FROM NPV n
RIGHT JOIN Queries q
ON n.id = q.id AND n.year = q.year;

"""

1440. Evaluate Boolean Expression


