# 177. Nth Highest Salary
1) https://leetcode.com/problems/nth-highest-salary/discuss/1013080/Mysql-%3A-Order-by-Limit
CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INT
BEGIN
SET N = N - 1;
  RETURN (
      # Write your MySQL query statement below.
      SELECT DISTINCT Salary
      FROM Employee 
      ORDER BY Salary DESC
      LIMIT 1 OFFSET N
  );
END
2)
CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INT
BEGIN
  RETURN (
      # Write your MySQL query statement below.
      SELECT DISTINCT Salary
      FROM (SELECT Salary, DENSE_RANK() OVER (ORDER BY Salary DESC) AS rnk
            FROM Employee) t
      WHERE rnk = N
  );
END

"""

# 178. Rank Scores
1)
SELECT Score AS score, DENSE_RANK() OVER (ORDER BY Score DESC) AS 'rank'
FROM Scores
2) https://leetcode.com/problems/rank-scores/discuss/456610/MySQL-Two-Simple-Solutions-and-Explanations-for-Beginners
SELECT S.Score, COUNT(S2.Score) AS 'Rank'
FROM Scores S, (SELECT DISTINCT Score FROM Scores) S2
WHERE S.Score<=S2.Score
GROUP BY S.Id 
ORDER BY S.Score DESC;

"""

# 180. Consecutive Numbers
1)
SELECT DISTINCT l2.Num AS ConsecutiveNums
FROM Logs l1, Logs l2, Logs l3
WHERE l2.Id - l1.Id = 1 AND l3.Id - l2.Id = 1
AND l1.Num = l2.Num AND l2.Num = l3.Num;
2)
select distinct Num as ConsecutiveNums
from Logs
where (Id + 1, Num) in (select * from Logs) and (Id + 2, Num) in (select * from Logs)
3) 
SELECT DISTINCT Num AS ConsecutiveNums
FROM (SELECT Id, Num,
      LAG(Num, 1) OVER (ORDER BY Id) AS Num_before,
      LEAD(Num, 1) OVER (ORDER BY Id) AS Num_after
      FROM Logs) t
WHERE Num = Num_before AND Num = Num_after;

"""

184. Department Highest Salary
1)
SELECT Department, Employee, Salary
FROM 
(SELECT d.Name AS Department, e.Name AS Employee, e.Salary,
        RANK() OVER (PARTITION BY d.Name ORDER BY e.Salary DESC) AS rnk
 FROM Employee e 
 JOIN Department d 
 ON e.DepartmentId = d.Id) t
WHERE rnk = 1;
2)
SELECT D.Name AS Department ,E.Name AS Employee ,E.Salary 
from Employee E
JOIN Department D 
ON E.DepartmentId = D.id 
WHERE (DepartmentId,Salary) in (SELECT DepartmentId,max(Salary) 
                                FROM Employee 
                                GROUP BY DepartmentId)
3)
select Department.Name as Department, e1.Name as Employee, Salary
from Employee e1, Department
where e1.DepartmentId = Department.Id 
and Salary >= ALL (select Salary from Employee e2 where e2.DepartmentId = e1.DepartmentId);
4)
SELECT dep.Name as Department, emp.Name as Employee, emp.Salary 
from Department dep, Employee emp 
where emp.DepartmentId=dep.Id 
and emp.Salary=(Select max(Salary) from Employee e2 where e2.DepartmentId=dep.Id)

"""

# 534. Game Play Analysis III
1)
SELECT player_id, 
       event_date, 
       SUM(games_played) OVER (PARTITION BY player_id ORDER BY event_date) AS games_played_so_far
FROM Activity;
2) exceed time limit
select player_id, 
       event_date, 
       (select sum(games_played) 
       from Activity 
       where player_id = a.player_id and event_date<=a.event_date) as "games_played_so_far"
from Activity a
3)
select a1.player_id, a1.event_date, sum(a2.games_played) as games_played_so_far
from Activity a1, Activity a2
where a1.player_id = a2.player_id and a2.event_date <= a1.event_date
group by a1.player_id, a1.event_date
order by a1.player_id, a1.event_date

"""

# 550. Game Play Analysis IV
1) https://leetcode.com/problems/game-play-analysis-iv/discuss/508062/MySQL-Without-JOIN-with-Explanation
SELECT ROUND(COUNT(DISTINCT player_id) / (SELECT COUNT(DISTINCT player_id) FROM Activity), 2) AS fraction
FROM activity
WHERE (player_id, SUBDATE(event_date, 1)) IN (SELECT player_id, MIN(event_date) 
                                              FROM Activity
                                              GROUP BY player_id)
2) https://leetcode.com/problems/game-play-analysis-iv/discuss/324851/MySQL-solution-with-STEP-BY-STEP-explanation
SELECT ROUND(SUM(a.event_date + 1 = b.event_date)/COUNT(DISTINCT a.player_id), 2) AS fraction 
FROM (SELECT player_id, MIN(event_date) AS event_date
      FROM Activity 
      GROUP BY player_id) AS a 
JOIN Activity AS b 
ON a.player_id = b.player_id
3) https://leetcode.com/problems/game-play-analysis-iv/discuss/995878/Using-LEAD-Straight-solution
SELECT ROUND(COUNT(DISTINCT player_id) / (SELECT COUNT(DISTINCT player_id) FROM Activity), 2) AS fraction
FROM (SELECT player_id, 
      MIN(event_date) OVER (PARTITION BY player_id) AS first_date, 
      LEAD(event_date, 1) OVER (PARTITION BY player_id ORDER BY event_date) AS date_after
      FROM Activity) t
WHERE date_after - first_date = 1

"""

# 570. Managers with at Least 5 Direct Reports
1)
SELECT DISTINCT e.Name
FROM Employee e
JOIN (SELECT ManagerId, COUNT(Id) OVER (PARTITION BY ManagerId) AS num
      FROM Employee) t
ON t.ManagerId = e.Id
WHERE num >= 5
2)
SELECT Name
FROM Employee
WHERE Id IN (SELECT ManagerId
             FROM Employee
             GROUP BY ManagerId
             HAVING COUNT(Id) >= 5);
3)
SELECT e2.Name
FROM Employee e1, Employee e2
WHERE e1.ManagerId = e2.Id
GROUP BY e2.Id
HAVING COUNT(e1.Id) >= 5

"""

# 574. Winning Candidate
1)
SELECT name
FROM Candidate  c
JOIN Vote v
ON c.id = v.Candidateid
GROUP BY Name 
ORDER BY COUNT(Name) DESC
LIMIT 1;
2)
SELECT c.Name
FROM Candidate c
JOIN (SELECT CandidateId, COUNT(*) AS num
      FROM Vote
      GROUP BY CandidateId
      ORDER BY num DESC
      LIMIT 1) t
ON c.id = t.CandidateId;
3)
SELECT c.Name
FROM Candidate c
JOIN (SELECT CandidateId, 
             COUNT(CandidateId) OVER (PARTITION BY CandidateId) AS num
      FROM Vote) t
ON c.id = t.CandidateId
ORDER BY num DESC
LIMIT 1;
4)
SELECT Name
FROM (SELECT CandidateId, RANK() OVER (ORDER BY COUNT(CandidateId) DESC) AS rnk
      FROM Vote
      GROUP BY CandidateId) t
JOIN Candidate
ON t.CandidateId = Candidate.id
WHERE rnk = 1 

"""

# 578. Get Highest Answer Rate Question

SELECT question_id AS survey_log
FROM survey_log
GROUP BY question_id
ORDER BY SUM(action = 'answer') / COUNT(*) DESC
LIMIT 1;

"""

# 580. Count Student Number in Departments
1)
SELECT dept_name, COUNT(student_id) AS student_number
FROM department
LEFT JOIN student 
USING (dept_id)
GROUP BY dept_name
ORDER BY 2 DESC, 1
2) https://leetcode.com/problems/count-student-number-in-departments/discuss/734641/MySQL%3A-Using-SUM(CASE-WHEN...)-instead-of-COUNT
SELECT dept_name, SUM(CASE WHEN s.dept_id THEN 1 ELSE 0 END) as student_number
FROM department d LEFT JOIN student s ON d.dept_id = s.dept_id
GROUP BY 1
ORDER BY 2 desc, 1

"""

# 585. Investments in 2016
1)
SELECT SUM(TIV_2016) AS TIV_2016
FROM insurance
WHERE TIV_2015 IN (SELECT TIV_2015
                   FROM insurance
                   GROUP BY TIV_2015
                   HAVING COUNT(TIV_2015) > 1)
AND (LAT, LON) IN (SELECT LAT, LON
                  FROM insurance
                  GROUP BY LAT, LON
                  HAVING COUNT(*) = 1)
2)
SELECT SUM(TIV_2016) AS TIV_2016
FROM (SELECT TIV_2016, 
             COUNT(TIV_2015) OVER (PARTITION BY TIV_2015) AS cnt2015,
             COUNT(*) OVER (PARTITION BY LAT, LON) AS cntloc
      FROM insurance) t
WHERE cnt2015 > 1 AND cntloc = 1 

"""

# 602. Friend Requests II: Who Has the Most Friends
1)
SELECT id1 AS id, COUNT(*) AS num
FROM (
    SELECT requester_id AS id1, accepter_id AS id2
    FROM request_accepted
    UNION 
    SELECT accepter_id AS id1, requester_id AS id2
    FROM request_accepted
    ) t
GROUP BY id1
ORDER BY num DESC
LIMIT 1;
2)
WITH t AS (SELECT accepter_id AS id, COUNT(requester_id) AS cnt
           FROM request_accepted 
           GROUP BY accepter_id
           UNION ALL
           SELECT requester_id AS id, COUNT(accepter_id) AS cnt
           FROM request_accepted
           GROUP BY requester_id)
SELECT id, SUM(cnt) AS num
FROM t 
GROUP BY id
ORDER BY num DESC
LIMIT 1;

"""

# 608. Tree Node
1) https://leetcode.com/problems/tree-node/discuss/219003/Need-help-!!-what's-wrong-with-my-code
SELECT id, CASE WHEN p_id IS NULL THEN 'Root'
                WHEN id NOT IN (SELECT DISTINCT p_id 
                                FROM tree
                                WHERE p_id IS NOT NULL) THEN 'Leaf'
                ELSE 'Inner' END AS Type
FROM tree
2) https://leetcode.com/problems/tree-node/discuss/104112/Solution-with-explanation%3A-CASE-%2B-LEFT-JOIN
SELECT DISTINCT t1.id, (
    CASE
    WHEN t1.p_id IS NULL  THEN 'Root'
    WHEN t1.p_id IS NOT NULL AND t2.id IS NOT NULL THEN 'Inner'
    WHEN t1.p_id IS NOT NULL AND t2.id IS NULL THEN 'Leaf'
    END
) AS Type 
FROM tree t1
LEFT JOIN tree t2
ON t1.id = t2.p_id
3)
select id,
case when p_id is null then 'Root'
when id in (select distinct p_id from tree) then 'Inner'
else 'Leaf'
end as 'Type'
from tree

"""

# 612. Shortest Distance in a Plane
1)
SELECT ROUND(MIN(SQRT(POWER(x1 - x2, 2) + POWER(y1 - y2, 2))), 2) AS shortest
FROM (SELECT p1.x AS x1, p2.x AS x2, p1.y AS y1, p2.y AS y2
      FROM point_2d p1
      CROSS JOIN point_2d p2
      WHERE (p1.x, p1.y) != (p2.x, p2.y)) t
2)
SELECT ROUND(MIN(SQRT(POWER(p1.x - p2.x, 2) + POWER(p1.y - p2.y, 2))), 2) AS shortest
FROM point_2d p1,point_2d p2
WHERE (p1.x, p1.y) != (p2.x, p2.y) 

"""

# 614. Second Degree Follower
1)
SELECT f1.follower, COUNT(DISTINCT f2.follower) AS num
FROM follow f1, follow f2
WHERE f1.follower = f2.followee
GROUP BY f1.follower
ORDER BY 1;
2)
SELECT followee AS follower, COUNT(DISTINCT follower) AS num
FROM follow
WHERE followee IN (SELECT DISTINCT follower
                   FROM follow)
GROUP BY followee
ORDER BY followee;

"""

# 626. Exchange Seats
1)
SELECT (CASE WHEN id % 2 = 0 THEN id - 1 
             WHEN id % 2 = 1 AND id != (SELECT COUNT(*) FROM seat) THEN id + 1
             ELSE id END) AS id,
        student
FROM seat 
ORDER BY id;
2)
SELECT id,
       IFNULL((CASE WHEN id % 2 = 1 THEN LEAD(student, 1) OVER (ORDER BY id)
             ELSE LAG(student, 1) OVER (ORDER BY id) END), student) AS student 
FROM seat 
ORDER BY id;
3)
SELECT id,
       CASE WHEN id % 2 = 0 THEN LAG(student) OVER (ORDER BY id)
            WHEN id % 2 = 1 AND id != (SELECT MAX(id) FROM seat) THEN LEAD(student) OVER (ORDER BY id)
            ELSE student END AS Student 
FROM seat 
ORDER BY id;

"""

# 1045. Customers Who Bought All Products

SELECT customer_id
FROM Customer
GROUP BY customer_id
HAVING COUNT(DISTINCT product_key) = (SELECT COUNT(*) FROM Product)

"""

# 1070. Product Sales Analysis III
1)
SELECT product_id, year AS first_year, quantity, price
FROM Sales
WHERE (product_id, year) IN (SELECT product_id, MIN(year) 
                             FROM Sales
                             GROUP BY product_id);
2)
SELECT product_id, year AS first_year, quantity, price
FROM (SELECT *, RANK() OVER (PARTITION BY product_id ORDER BY year) AS rnk
      FROM Sales) t
WHERE rnk = 1;

"""

# 1077. Project Employees III
1)
WITH t AS (SELECT project_id, 
                  employee_id,
                  RANK() OVER (PARTITION BY project_id ORDER BY experience_years DESC) AS rnk
           FROM Project
           JOIN Employee 
           USING (employee_id))

SELECT project_id, employee_id
FROM t
WHERE rnk = 1;
2)
SELECT project_id, employee_id 
FROM Project 
JOIN Employee
USING (employee_id)
WHERE (project_id, experience_years) IN (SELECT project_id, MAX(experience_years)
                                         FROM Project
                                         JOIN Employee
                                         USING (employee_id)
                                         GROUP BY project_id);

"""

# 1098. Unpopular Books
1)
SELECT b.book_id, name 
FROM Books b
LEFT JOIN Orders o
ON b.book_id = o.book_id
WHERE DATEDIFF('2019-06-23', available_from) >= 30
GROUP BY 1, 2
HAVING SUM(IF(dispatch_date BETWEEN '2018-06-23' AND '2019-06-23', quantity, 0)) < 10;
2)
SELECT book_id, 
       name
FROM Books
WHERE available_from < '2019-05-23'
AND book_id NOT IN
            (SELECT book_id
             FROM Orders
             WHERE dispatch_date BETWEEN '2018-06-23' AND '2019-06-23'
             GROUP BY book_id
             Having sum(quantity) >= 10)
3)
SELECT b.book_id, b.name
FROM Books b
LEFT JOIN Orders o
ON b.book_id = o.book_id AND dispatch_date BETWEEN '2018-06-23' AND '2019-06-23'
WHERE DATEDIFF('2019-06-23', available_from) > 30
GROUP BY b.book_id, b.name
HAVING IFNULL(SUM(quantity), 0) < 10;

"""

# 1107. New Users Daily Count
1)
SELECT first_login AS login_date, COUNT(user_id) AS user_count
FROM (SELECT user_id, MIN(activity_date) as first_login
      FROM Traffic
      WHERE activity = 'login' 
      GROUP BY user_id) t
WHERE DATEDIFF('2019-06-30', first_login) <= 90
GROUP BY login_date;
2)
SELECT min_date AS login_date, COUNT(DISTINCT user_id) AS user_count
FROM (SELECT *, 
             MIN(activity_date) OVER (PARTITION BY user_id) AS min_date
      FROM Traffic
      WHERE activity = 'login') t
WHERE DATEDIFF('2019-06-30', min_date) <= 90
GROUP BY 1;
3)
SELECT activity_date AS login_date, COUNT(DISTINCT user_id) AS user_count
FROM Traffic 
WHERE DATEDIFF('2019-06-30', activity_date) <= 90
AND (user_id, activity_date) IN (SELECT user_id, MIN(activity_date)
                                 FROM Traffic
                                 WHERE activity = 'login'
                                 GROUP BY user_id
                                 )
GROUP BY login_date;

"""

# 1112. Highest Grade For Each Student
1)
SELECT student_id, MIN(course_id) AS course_id, grade
FROM Enrollments
WHERE (student_id, grade) IN (SELECT student_id, MAX(grade)
                              FROM Enrollments
                              GROUP BY student_id)
GROUP BY student_id, grade
ORDER BY 1;
2)
SELECT student_id, course_id, grade
FROM (SELECT *, 
      RANK() OVER (PARTITION BY student_id ORDER BY grade DESC, course_id ASC) AS rnk
      FROM Enrollments) t
WHERE rnk = 1;

"""

# 1126. Active Businesses
1)
WWITH t AS (
    SELECT event_type, AVG(occurences) AS avg
    FROM Events
    GROUP BY event_type
)
SELECT business_id
FROM Events e, t
WHERE e.occurences > avg AND t.event_type = e.event_type
GROUP BY business_id
HAVING COUNT(e.event_type) > 1
2)
SELECT business_id
FROM (SELECT *, AVG(occurences) OVER (PARTITION BY event_type) AS avg_o
      FROM Events) t 
WHERE occurences > avg_o
GROUP BY business_id
HAVING COUNT(*) > 1;
3)
with agged as (
    select business_id
    , if(occurences > avg(occurences) over (partition by event_type), 1, 0) bool_flag
    from events
) select business_id
from agged
group by business_id
having sum(bool_flag) > 1

"""

1132. Reported Posts II

WITH t AS (SELECT action_date, 100* COUNT(DISTINCT Removals.post_id) / COUNT(DISTINCT post_id) AS avg_r
           FROM Actions
           LEFT JOIN Removals 
           USING (post_id)
           WHERE extra = 'spam'
           GROUP BY action_date)
SELECT ROUND(AVG(avg_r), 2) AS average_daily_percent
FROM t 

"""

1149. Article Views II

SELECT DISTINCT viewer_id AS id
FROM Views
GROUP BY viewer_id, view_date
HAVING COUNT(DISTINCT article_id) > 1
ORDER BY id;

"""

1158. Market Analysis I
1)
SELECT user_id AS buyer_id, join_date, IFNULL(COUNT(order_id), 0) AS orders_in_2019
FROM Users
LEFT JOIN Orders
ON Users.user_id = Orders.buyer_id AND YEAR(order_date) = 2019  #If you use 'where' then those who doesn't have 2019 sale won't be joined at all
GROUP BY user_id, join_date;
2)
WITH new AS (SELECT buyer_id, COUNT(order_id) AS orders_tot
             FROM Orders
             WHERE YEAR(order_date)=2019
             GROUP BY buyer_id)
SELECT U.user_id AS buyer_id, U.join_date , IFNULL(orders_tot,0) AS orders_in_2019
FROM Users AS U
LEFT JOIN new
ON U.user_id=new.buyer_id
3)
select u.user_id as buyer_id, join_date, sum(case when YEAR(order_date) = '2019' then 1 else 0 end) as orders_in_2019
from Users u left join Orders o on u.user_id = o.buyer_id
group by u.user_id

"""

1164. Product Price at a Given Date
1)
SELECT DISTINCT Products.product_id, IFNULL(t.new_price, 10) AS price
FROM (SELECT *, RANK() OVER (PARTITION BY product_id ORDER BY change_date DESC) AS rnk
      FROM Products
      WHERE change_date <= '2019-08-16') t 
RIGHT JOIN Products 
ON t.product_id = Products.product_id AND rnk = 1 
2)
SELECT DISTINCT p.product_id, IFNULL(temp.new_price, 10) AS price 
FROM (SELECT *
      FROM Products
      WHERE (product_id, change_date) IN (SELECT product_id, MAX(change_date)
                                          FROM Products
                                          WHERE change_date <= '2019-08-16'
                                          GROUP BY product_id)) temp
RIGHT JOIN Products p
USING (Product_id);

"""

1174. Immediate Food Delivery II
1)
WITH temp AS (
SELECT *, IF(order_date = customer_pref_delivery_date, 'immediate', 'scheduled') AS note
FROM Delivery
WHERE (customer_id, order_date) IN (SELECT customer_id, MIN(order_date)
                                    FROM Delivery
                                    GROUP BY customer_id))
SELECT ROUND(SUM(note = 'immediate') / COUNT(delivery_id) * 100, 2) AS immediate_percentage
FROM temp
2)
SELECT ROUND(SUM(order_date = customer_pref_delivery_date) / COUNT(delivery_id) * 100, 2) AS immediate_percentage
FROM Delivery
WHERE (customer_id, order_date) IN (SELECT customer_id, MIN(order_date)
                                    FROM Delivery
                                    GROUP BY customer_id)
                                    
"""

1193. Monthly Transactions I

SELECT DATE_FORMAT(trans_date, '%Y-%m') AS month,
       country,
       COUNT(id) AS trans_count,
       SUM(state = 'approved') AS approved_count,
       SUM(amount) AS trans_total_amount,
       SUM(IF(state = 'approved', amount, 0)) AS approved_total_amount
FROM Transactions
GROUP BY month, country;

"""

1204. Last Person to Fit in the Elevator
1)
SELECT q1.person_name
FROM Queue q1, Queue q2
WHERE q1.turn >= q2.turn
GROUP BY q1.turn
HAVING SUM(q2.weight) <= 1000
ORDER BY SUM(q2.weight) DESC
LIMIT 1
2)
SELECT person_name 
FROM (SELECT *, SUM(weight) OVER (ORDER BY turn) AS running_sum
      FROM Queue) t
WHERE running_sum <= 1000
ORDER BY running_sum DESC
LIMIT 1;

"""

1205. Monthly Transactions II
1)
WITH t AS (
    SELECT c.trans_id, DATE_FORMAT(c.trans_date, '%Y-%m') AS month, country, 'chargeback' AS state, amount
    FROM Chargebacks c  
    JOIN Transactions t  
    ON c.trans_id = t.id
    UNION
    SELECT t.id, DATE_FORMAT(t.trans_date, '%Y-%m') AS month, country, state, amount 
    FROM Transactions t)
    
SELECT month, country, SUM(state = 'approved') AS approved_count, SUM(IF(state = 'approved', amount, 0)) AS approved_amount, SUM(state = 'chargeback') AS chargeback_count, SUM(IF(state = 'chargeback', amount, 0)) AS chargeback_amount
FROM t 
GROUP BY month, country
HAVING approved_count + approved_amount + chargeback_count + chargeback_amount != 0 ;
2)
WITH t AS (
    SELECT LEFT(c.trans_date, 7) AS month, country, "chargeback" AS state, amount
    FROM chargebacks c
    JOIN transactions t ON c.trans_id = t.id
    UNION ALL
    SELECT LEFT(trans_date, 7) AS month, country, state, amount
    FROM transactions t
    WHERE state = "approved"    # If we do not filter out declined transactions at the beginning, we may get entries that have 0 for all four columns, which shouldn't be included in the result.
)
SELECT month, 
       country, 
       SUM(state = "approved") AS approved_count, 
       SUM(IF(state = 'approved', amount, 0)) AS approved_amount, 
       SUM(state = "chargeback") AS chargeback_count, 
       SUM(IF(state = "chargeback", amount, 0)) AS chargeback_amount
FROM t
GROUP BY month, country;

"""

1212. Team Scores in Football Tournament
1)
WITH temp AS (
    SELECT host_team AS team_id, 
    SUM(CASE WHEN host_goals > guest_goals THEN 3
             WHEN host_goals = guest_goals THEN 1
             ELSE 0 END) AS points
    FROM Matches 
    GROUP BY host_team
    UNION ALL
    SELECT guest_team AS team_id, 
           SUM(CASE WHEN guest_goals > host_goals THEN 3
           WHEN guest_goals = host_goals THEN 1
           ELSE 0 END) AS points
    FROM Matches
    GROUP BY guest_team
)
    
SELECT t.team_id, team_name, IFNULL(SUM(points), 0) AS num_points
FROM Teams t 
LEFT JOIN temp
USING (team_id)
GROUP BY 1, 2
ORDER BY num_points DESC, 1;
2)
SELECT team_id, team_name,
SUM(
    CASE WHEN team_id = host_team AND host_goals > guest_goals THEN 3
         WHEN team_id = guest_team AND guest_goals > host_goals THEN 3
         WHEN host_goals = guest_goals THEN 1
         ELSE 0
    END          
) AS "num_points"
FROM Teams t
LEFT JOIN Matches m ON t.team_id = m.host_team OR t.team_id = m.guest_team
GROUP BY team_id, team_name
ORDER BY num_points DESC, team_id;
3)
select team_id, team_name,
sum(case when team_id = host_team and host_goals > guest_goals then 3 else 0 end) +
sum(case when team_id = guest_team and guest_goals > host_goals then 3 else 0 end) +
sum(case when team_id = host_team and host_goals = guest_goals then 1 else 0 end) +
sum(case when team_id = guest_team and host_goals = guest_goals then 1 else 0 end)
as 'num_points'
from teams
left join matches
on team_id = host_team
or team_id = guest_team
group by team_id, team_name
order by num_points desc, team_id asc;

"""

1264. Page Recommendations
1)
SELECT DISTINCT page_id AS recommended_page
FROM Friendship f
JOIN Likes l
ON f.user1_id = l.user_id OR f.user2_id = l.user_id
WHERE (f.user1_id = 1 or f.user2_id = 1) 
AND page_id NOT IN (SELECT DISTINCT page_id
                      FROM Likes
                      WHERE user_id = 1)                   
2)
WITH t AS (
    SELECT user1_id, user2_id AS user_id
    FROM Friendship
    WHERE user1_id = 1
    UNION
    SELECT user2_id, user1_id AS user_id
    FROM Friendship
    WHERE user2_id = 1
)
SELECT DISTINCT page_id AS recommended_page
FROM t
JOIN Likes l
USINg (user_id)
WHERE page_id NOT IN (SELECT DISTINCT page_id
                      FROM Likes
                      WHERE user_id = 1)
3)
SELECT DISTINCT page_id as recommended_page
FROM (
    SELECT CASE WHEN user1_id = 1 then user2_id
                WHEN user2_id = 1 then user1_id
                END AS user_id
FROM Friendship) t
JOIN Likes l
on t.user_id = l.user_id
WHERE page_id NOT IN (SELECT DISTINCT page_id 
                      FROM Likes 
                      WHERE user_id = 1);

"""

1270. All People Report to the Given Manager
1)
SELECT e1.employee_id
FROM Employees e1
JOIN Employees e2
ON e1.manager_id = e2.employee_id
JOIN Employees e3
ON e2.manager_id = e3.employee_id
WHERE e3.manager_id = 1 AND e1.employee_id != 1
  
Alternative:
 SELECT e1.employee_id
FROM Employees e1,
     Employees e2,
     Employees e3
WHERE e1.manager_id = e2.employee_id
  AND e2.manager_id = e3.employee_id
  AND e3.manager_id = 1 
  AND e1.employee_id != 1
2)
with recursive cte1(id,n) as
(
    select employee_id as id, 1 as n
    from employees
    where manager_id=1 and employee_id!=1
    union
    select employee_id as id,n+1 as n
    from employees, cte1
    where manager_id=cte1.id and n+1<4
)
select id as employee_id 
from cte1
3)
SELECT a.employee_id as EMPLOYEE_ID 
FROM Employees as a      # those whose boss is 1
WHERE a.employee_id!=1 AND a.manager_id=1
UNION
SELECT b.employee_id 
FROM Employees as b      #those whose boss' boss is 1
WHERE b.manager_id IN (SELECT a.employee_id 
                       FROM Employees as a
                       WHERE a.employee_id!=1 AND a.manager_id=1)
UNION
SELECT c.employee_id FROM Employees as c      #those whose boss' boss' boss is 1
WHERE c.manager_id IN (SELECT b.employee_id 
                       FROM Employees as b
                       WHERE b.manager_id IN (SELECT a.employee_id 
                                              FROM Employees as a
                                              WHERE a.employee_id!=1 AND a.manager_id=1))
ORDER BY EMPLOYEE_ID;

"""

1285. Find the Start and End Number of Continuous Ranges

# the difference of (log_id - num) will change whenever a log_id is skipped. The rows with same difference (log_id - num), 
should be a continuous series. Then we just need to find the min, and max for that series as start/ end id. 
log_id, num, difference
1, 1, 0
2, 2, 0
3, 3, 0
7, 4, 3
8, 5, 3
10, 6, 4

SELECT MIN(log_id) as start_id, MAX(log_id) AS end_id
FROM (SELECT log_id, 
             ROW_NUMBER() OVER(ORDER BY log_id) as num
      FROM Logs) a
GROUP BY log_id - num;

"""

1308. Running Total for Different Genders
1)
SELECT gender, day, SUM(score_points) OVER (PARTITION BY gender ORDER BY day) AS total
FROM Scores 
ORDER BY gender, day;
2)
SELECT s1.gender, s1.day, SUM(s2.score_points) AS total
FROM Scores AS s1,
     Scores AS s2
WHERE s1.gender = s2.gender AND s2.day <= s1.day
GROUP BY s1.gender, s1.day
ORDER BY s1.gender, s1.day

"""

1321. Restaurant Growth
1)
WITH temp AS (
    SELECT visited_on, 
           SUM(amount) OVER(ORDER BY visited_on ROWS BETWEEN 6 PRECEDING AND CURRENT ROW) AS amount,
           ROUND(AVG(amount) OVER(ORDER BY visited_on ROWS BETWEEN 6 PRECEDING AND CURRENT ROW), 2) AS average_amount
    FROM (SELECT visited_on, SUM(amount) AS amount
          FROM Customer
          GROUP BY visited_on) t
)
SELECT *
FROM temp 
WHERE DATE_SUB(visited_on, INTERVAL 6 DAY) IN (SELECT DISTINCT visited_on FROM Customer);

2) https://leetcode.com/problems/restaurant-growth/discuss/1005697/MySQL-Easy-to-Read-and-Faster-Than-85-(w-Window-Function)
with sum_table as (
select distinct visited_on,
sum(amount) over (order by visited_on range between interval 6 day preceding and current row) as amount,
-- note that we use range to get the preceding 6 days
dense_rank() over (order by visited_on) as days
-- we need to remove the first 6 days from the output, note that dense_rank() is used to avoid gap in rank
from Customer
)
select visited_on, amount, round(amount/7,2) as average_amount
from sum_table
where days >= 7;

3) fastest method
SELECT b.visited_on, 
       SUM(a.amount) AS amount, 
       ROUND(SUM(a.amount)/7,2) AS average_amount
FROM Customer a, 
     (SELECT DISTINCT visited_on 
      FROM Customer) b
WHERE DATEDIFF(b.visited_on, a.visited_on) BETWEEN 0 AND 6
GROUP BY b.visited_on
HAVING COUNT(DISTINCT a.visited_on) = 7

"""

1341. Movie Rating
1)
WITH t1 AS (SELECT name, 
                   RANK() OVER (ORDER BY COUNT(DISTINCT movie_id) DESC, name) AS rnk
            FROM Movie_Rating 
            JOIN Users USING (user_id)
            GROUP BY user_id),
     t2 AS (SELECT title,
                   RANK() OVER (ORDER BY AVG(rating) DESC, title) AS rnk
            FROM Movies
            JOIN Movie_Rating USING (movie_id)
            WHERE LEFT(created_at, 7) = '2020-02'
            GROUP BY title)    
SELECT name AS results
FROM t1
WHERE t1.rnk = 1
UNION
SELECT title As results
FROM t2
WHERE t2.rnk = 1;

2) https://leetcode.com/problems/movie-rating/discuss/502651/MySQL-solution-using-UNION-SELECT-and-GROUP-BY
SELECT user_name as results FROM
(
    SELECT b.name as user_name,COUNT(*) as counts FROM Movie_rating as a
    JOIN Users as b
    ON a.user_id=b.user_id
    GROUP BY a.user_id
    ORDER BY counts DESC,user_name ASC LIMIT 1
) first_query #query for the person who rates the greatest number of movies
UNION
SELECT movie_name as results FROM
(
    SELECT d.title as movie_name,AVG(c.rating) as grade FROM Movie_rating as c
    JOIN Movies as d
    ON c.movie_id=d.movie_id
    WHERE SUBSTR(c.created_at,1,7)="2020-02"
    GROUP BY c.movie_id
    ORDER BY grade DESC,movie_name ASC LIMIT 1
) second_query; #query for the movie with the highest average rating in February

"""

1355. Activity Participants
1)
WITH t AS(
    SELECT activity,
           RANK() OVER (ORDER BY COUNT(id) DESC) AS rnk1,
           RANK() OVER (ORDER BY COUNT(id)) AS rnk2
    FROM Friends
    GROUP BY activity)
SELECT activity
FROM t 
WHERE rnk1 != 1 AND rnk2 != 1
2)
SELECT activity 
FROM friends
GROUP BY activity
HAVING COUNT(id) > (SELECT COUNT(id) 
                    FROM friends 
                    GROUP BY activity 
                    ORDER BY 1 
                    LIMIT 1)
AND COUNT(id) < (SELECT COUNT(id) 
                 FROM friends 
                 GROUP BY activity 
                 ORDER BY 1 DESC 
                 LIMIT 1); 
                 
"""                 

1364. Number of Trusted Contacts of a Customer
1)
WITH temp AS (
    SELECT customer_id, 
           customer_name, 
           COUNT(contact_name) AS contacts_cnt, 
           SUM(CASE WHEN contact_email IN (SELECT email FROM Customers) THEN 1 ELSE 0 END) AS trusted_contacts_cnt
    FROM Contacts c1
    RIGHT JOIN Customers c2
    ON c1.user_id = c2.customer_id
    GROUP BY 1, 2)
SELECT invoice_id, customer_name, price, contacts_cnt, trusted_contacts_cnt
FROM temp
RIGHT JOIN invoices 
ON temp.customer_id = Invoices.user_id
ORDER BY invoice_id;

2)https://leetcode.com/problems/number-of-trusted-contacts-of-a-customer/discuss/562342/Easy-MS-SQL
select
    i.invoice_id,
    c.customer_name,
    i.price,
    count(con.user_id) as contacts_cnt,
    count(c2.email) as trusted_contacts_cnt
from invoices i
join customers c on c.customer_id = i.user_id
left join contacts con on con.user_id = c.customer_id
left join customers c2 on c2.email = con.contact_email
group by i.invoice_id, c.customer_name, i.price
order by i.invoice_id;

3) https://leetcode.com/problems/number-of-trusted-contacts-of-a-customer/discuss/900767/MySQL-with-CTE-simpler-than-most-of-the-answers-and-beats-98
WITH cte AS
(SELECT user_id, count(contact_email) contacts_cnt, SUM(contact_email IN (SELECT email FROM Customers)) trusted_contacts_cnt
FROM Contacts
GROUP BY 1)
SELECT i.invoice_id, c.customer_name, i.price, IFNULL(contacts_cnt, 0) contacts_cnt, IFNULL(trusted_contacts_cnt, 0) trusted_contacts_cnt
FROM Invoices i
LEFT JOIN Customers c
ON i.user_id = c.customer_id
LEFT JOIN cte
ON i.user_id = cte.user_id
ORDER BY 1;

""""

1393. Capital Gain/Loss
SELECT stock_name, 
       SUM(IF(operation = 'Buy', - price, price)) AS capital_gain_loss
FROM Stocks
GROUP BY stock_name; 

"""

1398. Customers Who Bought Products A and B but Not C
1)
SELECT *
FROM Customers 
WHERE customer_id IN (SELECT customer_id
                    FROM Orders
                    GROUP BY customer_id
                    HAVING SUM(product_name = 'A') > 0
                    AND SUM(product_name = 'B') > 0
                    AND SUM(product_name = 'C') = 0)
2)
select a.customer_id, a.customer_name
from customers a , orders b
where a.customer_id  = b.customer_id
group by a.customer_id
having sum(b.product_name="A") >0 and sum(b.product_name="B") > 0 and sum(b.product_name="C")=0

3) https://leetcode.com/problems/customers-who-bought-products-a-and-b-but-not-c/discuss/563827/100-Left-Outer-Join
SELECT c.customer_id, c.customer_name
FROM Customers c
JOIN Orders a ON a.customer_id = c.customer_id AND a.product_name = "A"
JOIN Orders b ON b.customer_id = c.customer_id AND b.product_name = "B"
LEFT OUTER JOIN Orders o on o.customer_id = c.customer_id AND o.product_name = "C"
WHERE o.order_id IS NULL;

"""

1421. NPV Queries

SELECT q.id, q.year, IFNULL(n.npv, 0) AS npv
FROM NPV n
RIGHT JOIN Queries q
ON n.id = q.id AND n.year = q.year;

"""

1440. Evaluate Boolean Expression
SELECT e.left_operand, e.operator, e.right_operand,
       CASE WHEN operator = '<' AND v1.value < v2.value THEN 'true'
            WHEN operator = '>' AND v1.value > v2.value THEN 'true'
            WHEN operator = '=' AND v1.value = v2.value THEN 'true'
            ELSE 'false' END AS value
FROM Variables v1
JOIN Expressions e
ON v1.name  = e.left_operand
JOIN Variables v2
ON v2.name = e.right_operand; 

"""

1445. Apples & Oranges

SELECT sale_date,
       SUM(IF(fruit = 'oranges', -1 * sold_num, sold_num)) AS diff
FROM Sales
GROUP BY sale_date
ORDER BY sale_date;

"""

1454. Active Users

1)https://leetcode.com/problems/active-users/discuss/642956/Simple-MySQL-solution-without-window-function
SELECT DISTINCT l1.id, A.name
FROM Logins l1
JOIN Logins l2
ON l1.id = l2.id AND DATEDIFF(l2.login_date, l1.login_date) BETWEEN 1 AND 4
JOIN Accounts A
ON l1.id = A.id
GROUP BY l1.id, l1.login_date
HAVING COUNT(DISTINCT l2.login_date) = 4;

2)
WITH t2 AS (
    SELECT id, 
           name, 
           login_date,
           lead(login_date, 4) OVER (PARTITION BY id ORDER BY login_date) AS lead_date
    FROM (SELECT DISTINCT id, login_date
          FROM Logins) t
JOIN Accounts USING (id)
    )
SELECT DISTINCt id, name
FROM t2 
WHERE DATEDIFF(lead_date, login_date) = 4;

"""

1459. Rectangles Area
Alternative: replace 'AND a.x_value != b.x_value AND a.y_value != b.y_value' with 'ABS(a.x_value - b.x_value) * ABS(a.y_value - b.y_value) != 0' 
SELECT a.id AS p1, 
       b.id AS p2, 
       ABS(a.x_value - b.x_value) * ABS(a.y_value - b.y_value) AS area
FROM Points a, Points b
WHERE a.id < b.id
AND a.x_value != b.x_value
AND a.y_value != b.y_value 
ORDER BY area DESC, p1, p2;

"""

1468. Calculate Salaries
1) faster 
SELECT company_id, 
       employee_id, 
       employee_name,
       ROUND(CASE WHEN MAX(salary) OVER (PARTITION BY company_id) < 1000 THEN salary
                  WHEN MAX(salary) OVER (PARTITION BY company_id) BETWEEN 1000 AND 10000 THEN salary * (1 - 0.24) 
                  ELSE salary * (1- 0.49) END) AS salary
FROM salaries
2)
WITH t AS (
    SELECT *,
           MAX(salary) OVER (PARTITION BY company_id) AS max_salary,
           CASE WHEN MAX(salary) OVER (PARTITION BY company_id) < 1000 THEN 0
                     WHEN MAX(salary) OVER (PARTITION BY company_id) BETWEEN 1000 AND 10000 THEN 0.24
                     ELSE 0.49 END AS tax_rate
FROM Salaries
    )
SELECT company_id, employee_id, employee_name, ROUND(salary * (1 - tax_rate)) AS salary
FROM t;
3)
WITH tax_multiplier AS (
SELECT company_id,
CASE WHEN MAX(salary) < 1000 THEN 1.0
WHEN MAX(salary) <= 10000 THEN 0.76
ELSE 0.51 END AS mult
FROM Salaries
GROUP BY company_id
)
SELECT s.company_id, s.employee_id, s.employee_name, ROUND(s.salary * t.mult) AS salary
FROM Salaries s JOIN tax_multiplier t ON s.company_id = t.company_id;

"""

1501. Countries You Can Safely Invest In
1)
SELECT Country.name AS country
FROM Country 
JOIN Person 
ON LEFT(Person.phone_number, 3) = Country.country_code 
JOIN Calls 
ON Calls.caller_id = Person.id OR Calls.callee_id = Person.id 
GROUP BY Country.name 
HAVING AVG(Calls.duration) > (SELECT AVG(duration)
                              FROM Calls)
2)
WITH t AS (
    SELECT caller_id AS id, duration
    FROM calls
    UNION ALL
    SELECT callee_id AS id, duration
    FROM calls
)
SELECT c.name AS country
FROM t
JOIN Person p USING (id)
JOIN Country c
ON c.country_code = LEFT(p.phone_number, 3)
GROUP BY country
HAVING AVG(duration) > (SELECT AVG(duration)
                        FROM Calls);
3)
SELECT DISTINCT country 
FROM (
    SELECT country.name country, 
           calls.duration,
           AVG(calls.duration) over(partition by country.name) avg_duration,
           AVG(calls.duration) over() avg_total
    FROM calls  
    JOIN person ON calls.caller_id = person.id or calls.callee_id = person.id
    JOIN country ON LEFT(person.phone_number, 3) = country.country_code
) t
WHERE avg_duration > avg_total;

"""

1532. The Most Recent Three Orders
SSELECT name AS customer_name, customer_id, order_id, order_date
FROM (
    SELECT name,
           customer_id, 
           order_date,
           order_id,
           cost,
           RANK() OVER (PARTITION BY customer_id ORDER BY order_date DESC) AS rnk
FROM Customers  
JOIN Orders 
USING (customer_id)) t 
WHERE rnk <= 3
ORDER BY customer_name, customer_id, order_date DESC;

"""

1549. The Most Recent Orders for Each Product
1)
SELECT product_name,  product_id, order_id, order_date
FROM (SELECT product_name, 
             product_id, 
             order_id, 
             order_date, 
             RANK() OVER (PARTITION BY product_id ORDER BY order_date DESC) AS rnk
      FROM Orders 
      JOIN Products USING (product_id)) t
WHERE rnk = 1 
ORDER BY 1, 2, 3;
2)
SELECT b.product_name, a.product_id, a.order_id, a.order_date 
FROM Orders a
JOIN Products b 
USING (product_id)
WHERE (a.product_id, a.order_date) IN (SELECT product_id, MAX(order_date) AS order_date
                                       FROM Orders
                                       GROUP BY product_id)
ORDER BY b.product_name, a.product_id, a.order_id;
3)
WITH t1 AS (
    SELECT p.product_name, p.product_id, max(o.order_date) as order_date
    FROM Orders o
    JOIN Products p 
    USING(product_id)
    GROUP BY 1
)
SELECT t1.product_name, t1.product_id, o.order_id, t1.order_date
FROM Orders o
JOIN t1 
ON o.order_date = t1.order_date AND t1.product_id = o.product_id
ORDER BY 1 ASC, 2 ASC, 3 ASC;

"""

1555. Bank Account Summary
1)
SELECT user_id, 
       user_name, 
       IFNULL(SUM(IF(user_id = paid_by, -amount, amount)), 0) + credit AS credit, 
       CASE WHEN IFNULL(SUM(IF(user_id = paid_by, -amount, amount)), 0) + credit > 0 THEN 'No' ELSE 'Yes' END AS credit_limit_breached
FROM Users u
LEFT JOIN Transactions t
ON u.user_id = t.paid_to OR u.user_id  = t.paid_by
GROUP BY u.user_id;
2)
WITH t AS(
    SELECT paid_by AS user_id, SUM(-amount) AS amount
    FROM Transactions 
    GROUP BY paid_by
    UNION ALL
    SELECT paid_to AS user_id, SUM(amount) AS amount
    FROM Transactions
    GROUP BY paid_to
    )
SELECT user_id, 
       user_name, 
       IFNULL(SUM(amount), 0) + credit AS credit,
       IF(IFNULL(SUM(amount), 0) + credit > 0, 'No', 'Yes') AS credit_limit_breached
FROM Users
LEFT JOIN t USING (user_id)
GROUP BY user_id, user_name;

"""

1596. The Most Frequently Ordered Products for Each Customer
1)
SELECT customer_id, product_id, product_name
FROM (
SELECT customer_id, product_id, product_name,
       RANK() OVER (PARTITION BY customer_id ORDER BY COUNT(product_id) DESC) AS rnk
FROM Customers
LEFT JOIN Orders USING (customer_id)
JOIN Products USING (product_id)
GROUP BY customer_id, product_id
    ) t
WHERE rnk = 1;
2)
SELECT customer_id,products.product_id,product_name
from Orders
JOIN Products on Products.product_id=Orders.product_id
group by customer_id,product_id
HAVING (customer_id,COUNT(order_date)) IN(
#Get Maxiumum Count for each customer 
SELECT customer_id,MAX(cnt)FROM
(
SELECT customer_id,product_id,COUNT(order_date) as cnt
from Orders
group by customer_id,product_id
) as a
group by customer_id)

"""

1613. Find the Missing IDs

WITH RECURSIVE t AS (
    SELECT 1 as num
    UNION 
    SELECT num + 1
    FROM t
    WHERE num < (SELECT MAX(customer_id) FROM Customers) 
)
SELECT num AS ids
FROM t
WHERE num NOT IN (SELECT customer_id FROM Customers);  

"""

1699. Number of Calls Between Two Persons
1)
SELECT LEAST(from_id,to_id) as person1,
GREATEST(from_id,to_id) as person2,
COUNT(*) as call_count,
SUM(duration) as total_duration
FROM Calls
GROUP BY person1,person2;
2)
WITH t AS (
    SELECT *
    FROM Calls 
    UNION ALL
    SELECT to_id AS from_id, from_id AS to_id, duration
    FROM Calls)
SELECT from_id AS person1, to_id AS person2, COUNT(*) AS call_count, SUM(duration) AS total_duration
FROM t 
WHERE from_id < to_id
GROUP BY 1, 2;
3)
SELECT CASE WHEN from_id > to_id THEN to_id
            ELSE from_id END AS person1,
       CASE WHEN from_id > to_id THEN from_id
            ELSE to_id END AS person2,
       COUNT(duration) AS call_count,
       SUM(duration) AS total_duration       
FROM Calls
GROUP BY person2, person1;

"""

1709. Biggest Window Between Visits
1)
WITH t AS (
    SELECT *,
           LEAD(visit_date, 1, '2021-1-1') OVER (PARTITION BY user_id ORDER BY visit_date) AS lead_date
    FROM UserVisits)

SELECT user_id, MAX(DATEDIFF(lead_date, visit_date)) AS biggest_window
FROM t 
GROUP BY user_id;
2)
SELECT user_id, MAX(diff) AS biggest_window
FROM
(
SELECT user_id,
DATEDIFF(LEAD(visit_date, 1, '2021-01-01') OVER (PARTITION BY user_id ORDER BY visit_date), visit_date) AS diff
	FROM userVisits
) a
GROUP BY user_id
ORDER BY user_id;

"""

1715. Count Apples and Oranges

SELECT SUM(b.apple_count) + IFNULL(SUM(c.apple_count), 0) AS apple_count,
       SUM(b.orange_count) + IFNULL(SUM(c.orange_count), 0) AS orange_count 
FROM Boxes b
LEFT JOIN Chests c 
USING (chest_id);

"""

1747. Leetflex Banned Accounts
1)
SELECT DISTINCT a.account_id
FROM loginfo a JOIN loginfo b 
ON a.account_id = b.account_id AND a.ip_address < b.ip_address
WHERE GREATEST(a.login, b.login) <= LEAST(a.logout, b.logout)
2)
SELECT DISTINCT a.account_id
FROM LogInfo a, LogInfo b
WHERE a.login between (b.login) and (b.logout)
AND a.account_id = b.account_id
AND a.ip_address !=b.ip_address;

"""

1783. Grand Slam Titles
1)
WITH t AS (
    SELECT Wimbledon AS player_id FROM Championships
    UNION ALL
    SELECT Fr_open AS player_id FROM Championships
    UNION ALL
    SELECT US_open AS player_id FROM Championships
    UNION ALL
    SELECT Au_open AS player_id FROM Championships
    )
SELECT player_id, player_name, COUNT(*) AS grand_slams_count
FROM Players
JOIN t USING (player_id)
GROUP BY player_id;
2)
SELECT player_id,
       player_name,
       SUM(player_id = Wimbledon) + SUM(player_id = Fr_open) + SUM(player_id = US_open) + SUM(player_id = Au_open) AS grand_slams_count
FROM Players
JOIN Championships
ON player_id = Wimbledon OR player_id = Fr_open OR player_id = US_open OR player_id = Au_open
GROUP BY player_id;

"""

1811. Find Interview Candidates

WITH t1 AS (SELECT gold_medal
            FROM Contests
            GROUP BY gold_medal
            HAVING COUNT(contest_id) >= 3),
     t2 AS (SELECT contest_id, gold_medal AS user_id FROM contests
            UNION ALL
            SELECT contest_id, silver_medal AS user_id FROM contests
            UNION ALL
            SELECT contest_id, bronze_medal AS user_id FROM contests), 
     t3 AS (SELECT user_id, contest_id, LEAD(contest_id, 2) OVER (PARTITION BY user_id ORDER BY contest_id) AS lag_contest
            FROM t2)
            
SELECT name, mail
FROM Users 
WHERE user_id IN (SELECT gold_medal FROM t1)
OR user_id IN (SELECT user_id
               FROM t3
               WHERE lag_contest - contest_id = 2);
               
2) https://leetcode.com/problems/find-interview-candidates/discuss/1142921/CTE-3-times-Union-All-with-Explanation
t3 as (select contest_id, user_id
       from t2
       where (contest_id+1, user_id) in (select contest_id, user_id from t2) 
       and (contest_id+2, user_id) in (select contest_id, user_id from t2))
3) https://leetcode.com/problems/find-interview-candidates/discuss/1144024/MySQL-Short-and-sweet-using-lag()-function
WITH cte AS (
    SELECT
        user_id,
        name,
        mail,
        contest_id,
        user_id = gold_medal as gold,
        user_id = silver_medal as silver,
        user_id = bronze_medal as bronze,
        lag(contest_id, 2) over (partition by user_id order by contest_id) as lag_contest
    FROM Users
    LEFT JOIN Contests 
    ON user_id = gold_medal OR user_id = silver_medal OR user_id = bronze_medal
)

SELECT name, mail
FROM cte
GROUP BY user_id
HAVING SUM(gold) >= 3
OR SUM(contest_id - lag_contest = 2) >= 1

"""

1831. Maximum Transaction Each Day
1)
SELECT transaction_id
FROM (
    SELECT transaction_id,
    DATE(day) AS day,
    amount,
    RANK() OVER (PARTITION BY DATE(day) ORDER BY amount DESC) AS rnk
    FROM Transactions 
    ) t
WHERE rnk = 1
ORDER BY 1;

2)
SELECT transaction_id 
FROM transactions 
WHERE (DATE(day), amount) IN (SELECT DATE(day) AS day, MAX(amount)
                              FROM transactions 
                              GROUP BY 1)
ORDER BY 1;

"""

1841. League Statistics
1)
WITH t AS ( 
    SELECT t.team_name,
           CASE WHEN t.team_id = m.home_team_id and home_team_goals > away_team_goals THEN 3
                WHEN t.team_id = m.home_team_id and home_team_goals = away_team_goals THEN 1
                WHEN t.team_id = m.away_team_id and home_team_goals = away_team_goals THEN 1
                WHEN t.team_id = m.away_team_id and home_team_goals < away_team_goals THEN 3
                ELSE 0 END as points,
            CASE WHEN t.team_id = m.home_team_id THEN home_team_goals ELSE away_team_goals END AS goal_for,
            CASE WHEN t.team_id = m.away_team_id THEN home_team_goals ELSE away_team_goals END AS goal_against
    FROM teams t
    JOIN matches m
    ON t.team_id = m.home_team_id OR t.team_id = m.away_team_id
    )
SELECT team_name, 
        COUNT(team_name) AS matches_played,
        SUM(points) as points,
        sum(goal_for) as goal_for,
        sum(goal_against) as goal_against,
        sum(goal_for-goal_against) as goal_diff
FROM t
GROUP BY team_name
ORDER BY points DESC, goal_diff DESC, team_name;

2) https://leetcode.com/problems/league-statistics/discuss/1226809/MySQL-fun-times
WITH t AS (
    SELECT t.team_name, m.home_team_id AS team_id, m.home_team_goals AS goals,
           CASE WHEN m.home_team_goals > m.away_team_goals THEN 3
                 WHEN m.home_team_goals = m.away_team_goals THEN 1
                 ELSE 0 END AS points,
           m.away_team_goals AS goal_against
    FROM Matches m 
    LEFT JOIN Teams t ON m.home_team_id = t.team_id
    UNION ALL
    SELECT t.team_name, m.away_team_id AS team_id, m.away_team_goals AS goals,
           CASE WHEN m.away_team_goals > m.home_team_goals THEN 3
                 WHEN m.away_team_goals = m.home_team_goals THEN 1
                 ELSE 0 END AS points,
           m.home_team_goals AS goal_against
    FROM Matches m 
    LEFT JOIN Teams t ON m.away_team_id = t.team_id
)
SELECT team_name,
       COUNT(*) AS matches_played,
       SUM(points) AS points,
       SUM(goals) AS goal_for,
       SUM(goal_against) AS goal_against,
       (SUM(goals) - SUM(goal_against)) AS goal_diff
FROM t
GROUP BY team_name
ORDER BY points DESC, goal_diff DESC, team_name;

"""

1843. Suspicious Bank Accounts
1)
WITH t1 AS (
    SELECT account_id, MONTH(day) AS month, SUM(amount) AS total
    FROM Transactions
    WHERE type = 'Creditor'
    GROUP BY 1, 2), 
     t2 AS (
         SELECT account_id,
                month,
                total, 
                max_income,
                LEAD(total) OVER (PARTITION BY account_id ORDER BY month) AS lead_total,
                LEAD(month) OVER (PARTITION BY account_id ORDER BY month) AS lead_month
         FROM t1
         JOIN Accounts USING (account_id))
SELECT DISTINCT account_id
FROM t2
WHERE lead_month - month = 1
AND lead_total > max_income
AND total > max_income;
2)
WITH t AS (
    SELECT account_id, 
           DATE_FORMAT(day,'%Y%m') AS date, 
           IF(SUM(amount) > max_income, 'Y', 'N') AS suspicious
    FROM transactions 
    JOIN accounts USING (account_id)
    WHERE type = 'Creditor'
    GROUP BY account_id, date
)

SELECT DISTINCT t1.account_id
FROM t t1, t t2
WHERE t1.account_id = t2.account_id 
AND PERIOD_DIFF(t1.date, t2.date)=1
AND t1.suspicious = 'Y' and t2.suspicious = 'Y';
