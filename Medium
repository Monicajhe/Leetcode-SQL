# 176. Second Highest Salary
1)/* the first select with out FROM is to return null if no match is found. Some databases may not support it. */
SELECT IFNULL((SELECT DISTINCT Salary 
               FROM Employee 
               ORDER BY Salary DESC
               LIMIT 1, 1), null) AS SecondHighestSalary

2)/* Using MAX() will return a NULL if the value doesn't exist. */
SELECT MAX(Salary) AS SecondHighestSalary
FROM Employee 
WHERE Salary < (SELECT MAX(Salary)
                FROM Employee);

3)
SELECT IFNULL
   ((SELECT DISTINCT Salary
     FROM (SELECT Salary, DENSE_RANK() OVER (ORDER BY Salary DESC) AS rnk
           FROM Employee) t      
     WHERE rnk = 2), null) AS SecondHighestSalary
     
"""

# 177. Nth Highest Salary
1) https://leetcode.com/problems/nth-highest-salary/discuss/1013080/Mysql-%3A-Order-by-Limit
CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INT
BEGIN
SET N = N - 1;
  RETURN (
      # Write your MySQL query statement below.
      SELECT DISTINCT Salary
      FROM Employee 
      ORDER BY Salary DESC
      LIMIT 1 OFFSET N
  );
END

2)
CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INT
BEGIN
  RETURN (
      # Write your MySQL query statement below.
      SELECT DISTINCT Salary
      FROM (SELECT Salary, DENSE_RANK() OVER (ORDER BY Salary DESC) AS rnk
            FROM Employee) t
      WHERE rnk = N
  );
END

"""

# 178. Rank Scores
1)
SELECT Score AS score, DENSE_RANK() OVER (ORDER BY Score DESC) AS 'rank'
FROM Scores

2) https://leetcode.com/problems/rank-scores/discuss/456610/MySQL-Two-Simple-Solutions-and-Explanations-for-Beginners
SELECT S.Score, COUNT(S2.Score) AS 'Rank'
FROM Scores S, (SELECT DISTINCT Score FROM Scores) S2
WHERE S.Score<=S2.Score
GROUP BY S.Id 
ORDER BY S.Score DESC;

"""

# 180. Consecutive Numbers
1)
SELECT DISTINCT l2.Num AS ConsecutiveNums
FROM Logs l1, Logs l2, Logs l3
WHERE l2.Id - l1.Id = 1 AND l3.Id - l2.Id = 1
AND l1.Num = l2.Num AND l2.Num = l3.Num;

2)
SELECT DISTINCT Num AS ConsecutiveNums
FROM Logs 
WHERE (Id + 1, Num) IN (SELECT Id, Num FROM Logs)
AND (Id + 2, Num) IN (SELECT Id, Num FROM Logs)

3) 
SELECT DISTINCT Num AS ConsecutiveNums
FROM (SELECT Id, Num,
      LAG(Num, 1) OVER (ORDER BY Id) AS Num_before,
      LEAD(Num, 1) OVER (ORDER BY Id) AS Num_after
      FROM Logs) t
WHERE Num = Num_before AND Num = Num_after;

"""

184. Department Highest Salary
1)
SELECT Department, Employee, Salary
FROM 
(SELECT d.Name AS Department, e.Name AS Employee, e.Salary,
        RANK() OVER (PARTITION BY d.Name ORDER BY e.Salary DESC) AS rnk
 FROM Employee e 
 JOIN Department d 
 ON e.DepartmentId = d.Id) t
WHERE rnk = 1;
2)
SELECT D.Name AS Department ,E.Name AS Employee ,E.Salary 
from Employee E
JOIN Department D 
ON E.DepartmentId = D.id 
WHERE (DepartmentId,Salary) in (SELECT DepartmentId,max(Salary) 
                                FROM Employee 
                                GROUP BY DepartmentId)
3)
select Department.Name as Department, e1.Name as Employee, Salary
from Employee e1, Department
where e1.DepartmentId = Department.Id 
and Salary >= ALL (select Salary from Employee e2 where e2.DepartmentId = e1.DepartmentId);
4)
SELECT dep.Name as Department, emp.Name as Employee, emp.Salary 
from Department dep, Employee emp 
where emp.DepartmentId=dep.Id 
and emp.Salary=(Select max(Salary) from Employee e2 where e2.DepartmentId=dep.Id)

"""

# 534. Game Play Analysis III
1)
SELECT player_id, 
       event_date, 
       SUM(games_played) OVER (PARTITION BY player_id ORDER BY event_date) AS games_played_so_far
FROM Activity;
2) exceed time limit
select player_id, 
       event_date, 
       (select sum(games_played) 
       from Activity 
       where player_id = a.player_id and event_date<=a.event_date) as "games_played_so_far"
from Activity a
3)
select a1.player_id, a1.event_date, sum(a2.games_played) as games_played_so_far
from Activity a1, Activity a2
where a1.player_id = a2.player_id and a2.event_date <= a1.event_date
group by a1.player_id, a1.event_date
order by a1.player_id, a1.event_date

"""

# 550. Game Play Analysis IV
1) https://leetcode.com/problems/game-play-analysis-iv/discuss/508062/MySQL-Without-JOIN-with-Explanation
SELECT ROUND(COUNT(DISTINCT player_id) / (SELECT COUNT(DISTINCT player_id) FROM Activity), 2) AS fraction
FROM activity
WHERE (player_id, SUBDATE(event_date, 1)) IN (SELECT player_id, MIN(event_date) 
                                              FROM Activity
                                              GROUP BY player_id)
2) https://leetcode.com/problems/game-play-analysis-iv/discuss/324851/MySQL-solution-with-STEP-BY-STEP-explanation
SELECT ROUND(SUM(a.event_date + 1 = b.event_date)/COUNT(DISTINCT a.player_id), 2) AS fraction 
FROM (SELECT player_id, MIN(event_date) AS event_date
      FROM Activity 
      GROUP BY player_id) AS a 
JOIN Activity AS b 
ON a.player_id = b.player_id
3) 
SELECT ROUND(COUNT(DISTINCT player_id) / (SELECT COUNT(DISTINCT player_id) FROM Activity), 2) AS fraction
FROM (
    SELECT *, MIN(event_date) OVER (PARTITION BY player_id ORDER BY event_date) AS min_date
    FROM Activity 
    ) t
WHERE min_date + 1 = event_date;

"""

# 570. Managers with at Least 5 Direct Reports
1)
SELECT DISTINCT e.Name
FROM Employee e
JOIN (SELECT ManagerId, COUNT(Id) OVER (PARTITION BY ManagerId) AS num
      FROM Employee) t
ON t.ManagerId = e.Id
WHERE num >= 5
2)
SELECT Name
FROM Employee
WHERE Id IN (SELECT ManagerId
             FROM Employee
             GROUP BY ManagerId
             HAVING COUNT(Id) >= 5);
3)
SELECT e2.Name
FROM Employee e1, Employee e2
WHERE e1.ManagerId = e2.Id
GROUP BY e2.Id
HAVING COUNT(e1.Id) >= 5

"""

# 574. Winning Candidate
1)
SELECT name
FROM Candidate  c
JOIN Vote v
ON c.id = v.Candidateid
GROUP BY Name 
ORDER BY COUNT(Name) DESC
LIMIT 1;
2)
SELECT c.Name
FROM Candidate c
JOIN (SELECT CandidateId, COUNT(*) AS num
      FROM Vote
      GROUP BY CandidateId
      ORDER BY num DESC
      LIMIT 1) t
ON c.id = t.CandidateId;
3)
SELECT c.Name
FROM Candidate c
JOIN (SELECT CandidateId, 
             COUNT(CandidateId) OVER (PARTITION BY CandidateId) AS num
      FROM Vote) t
ON c.id = t.CandidateId
ORDER BY num DESC
LIMIT 1;
4)
SELECT Name
FROM (SELECT CandidateId, RANK() OVER (ORDER BY COUNT(CandidateId) DESC) AS rnk
      FROM Vote
      GROUP BY CandidateId) t
JOIN Candidate
ON t.CandidateId = Candidate.id
WHERE rnk = 1 

"""

# 578. Get Highest Answer Rate Question

SELECT question_id AS survey_log
FROM survey_log
GROUP BY question_id
ORDER BY SUM(action = 'answer') / COUNT(*) DESC
LIMIT 1;

"""

# 580. Count Student Number in Departments
1)
SELECT dept_name, COUNT(student_id) AS student_number
FROM department
LEFT JOIN student 
USING (dept_id)
GROUP BY dept_name
ORDER BY 2 DESC, 1
2) https://leetcode.com/problems/count-student-number-in-departments/discuss/734641/MySQL%3A-Using-SUM(CASE-WHEN...)-instead-of-COUNT
SELECT dept_name, SUM(CASE WHEN s.dept_id THEN 1 ELSE 0 END) as student_number
FROM department d LEFT JOIN student s ON d.dept_id = s.dept_id
GROUP BY 1
ORDER BY 2 desc, 1
3)
SELECT DISTINCT dept_name, COUNT(student_id) OVER (PARTITION BY dept_id) AS student_number
FROM student
RIGHT JOIN department
USING (dept_id)
ORDER BY 2 DESC, 1;

"""

# 585. Investments in 2016
1)
SELECT SUM(TIV_2016) AS TIV_2016
FROM insurance
WHERE TIV_2015 IN (SELECT TIV_2015
                   FROM insurance
                   GROUP BY TIV_2015
                   HAVING COUNT(TIV_2015) > 1)
AND (LAT, LON) IN (SELECT LAT, LON
                  FROM insurance
                  GROUP BY LAT, LON
                  HAVING COUNT(*) = 1)
2)
SELECT SUM(TIV_2016) AS TIV_2016
FROM (SELECT TIV_2016, 
             COUNT(TIV_2015) OVER (PARTITION BY TIV_2015) AS cnt2015,
             COUNT(*) OVER (PARTITION BY LAT, LON) AS cntloc
      FROM insurance) t
WHERE cnt2015 > 1 AND cntloc = 1 

"""

# 602. Friend Requests II: Who Has the Most Friends
1)
SELECT id1 AS id, COUNT(*) AS num
FROM (
    SELECT requester_id AS id1, accepter_id AS id2
    FROM request_accepted
    UNION 
    SELECT accepter_id AS id1, requester_id AS id2
    FROM request_accepted
    ) t
GROUP BY id1
ORDER BY num DESC
LIMIT 1;
2)
WITH t AS (SELECT accepter_id AS id, COUNT(requester_id) AS cnt
           FROM request_accepted 
           GROUP BY accepter_id
           UNION ALL
           SELECT requester_id AS id, COUNT(accepter_id) AS cnt
           FROM request_accepted
           GROUP BY requester_id)
SELECT id, SUM(cnt) AS num
FROM t 
GROUP BY id
ORDER BY num DESC
LIMIT 1;

"""

# 608. Tree Node
1) https://leetcode.com/problems/tree-node/discuss/219003/Need-help-!!-what's-wrong-with-my-code
SELECT id, CASE WHEN p_id IS NULL THEN 'Root'
                WHEN id NOT IN (SELECT DISTINCT p_id 
                                FROM tree
                                WHERE p_id IS NOT NULL) THEN 'Leaf'
                ELSE 'Inner' END AS Type
FROM tree
2) https://leetcode.com/problems/tree-node/discuss/104112/Solution-with-explanation%3A-CASE-%2B-LEFT-JOIN
SELECT DISTINCT t1.id, (
    CASE
    WHEN t1.p_id IS NULL  THEN 'Root'
    WHEN t1.p_id IS NOT NULL AND t2.id IS NOT NULL THEN 'Inner'
    WHEN t1.p_id IS NOT NULL AND t2.id IS NULL THEN 'Leaf'
    END
) AS Type 
FROM tree t1
LEFT JOIN tree t2
ON t1.id = t2.p_id
3)
select id,
case when p_id is null then 'Root'
when id in (select distinct p_id from tree) then 'Inner'
else 'Leaf'
end as 'Type'
from tree

"""

# 612. Shortest Distance in a Plane
1)
SELECT ROUND(MIN(SQRT(POWER(x1 - x2, 2) + POWER(y1 - y2, 2))), 2) AS shortest
FROM (SELECT p1.x AS x1, p2.x AS x2, p1.y AS y1, p2.y AS y2
      FROM point_2d p1
      CROSS JOIN point_2d p2
      WHERE (p1.x, p1.y) != (p2.x, p2.y)) t
2)
SELECT ROUND(MIN(SQRT(POWER(p1.x - p2.x, 2) + POWER(p1.y - p2.y, 2))), 2) AS shortest
FROM point_2d p1,point_2d p2
WHERE (p1.x, p1.y) != (p2.x, p2.y) 

"""

# 614. Second Degree Follower
1)
SELECT f1.follower, COUNT(DISTINCT f2.follower) AS num
FROM follow f1, follow f2
WHERE f1.follower = f2.followee
GROUP BY f1.follower
ORDER BY 1;
2)
SELECT followee AS follower, COUNT(DISTINCT follower) AS num
FROM follow
WHERE followee IN (SELECT DISTINCT follower
                   FROM follow)
GROUP BY followee
ORDER BY followee;

"""

# 626. Exchange Seats
1)
SELECT (CASE WHEN id % 2 = 0 THEN id - 1 
             WHEN id % 2 = 1 AND id != (SELECT COUNT(*) FROM seat) THEN id + 1
             ELSE id END) AS id,
        student
FROM seat 
ORDER BY id;
2)
SELECT id,
       IFNULL((CASE WHEN id % 2 = 1 THEN LEAD(student, 1) OVER (ORDER BY id)
             ELSE LAG(student, 1) OVER (ORDER BY id) END), student) AS student 
FROM seat 
ORDER BY id;
3)
SELECT id,
       CASE WHEN id % 2 = 0 THEN LAG(student) OVER (ORDER BY id)
            WHEN id % 2 = 1 AND id != (SELECT MAX(id) FROM seat) THEN LEAD(student) OVER (ORDER BY id)
            ELSE student END AS Student 
FROM seat 
ORDER BY id;

"""

# 1045. Customers Who Bought All Products

SELECT customer_id
FROM Customer
GROUP BY customer_id
HAVING COUNT(DISTINCT product_key) = (SELECT COUNT(*) FROM Product)

"""

# 1070. Product Sales Analysis III
1)
SELECT product_id, year AS first_year, quantity, price
FROM Sales
WHERE (product_id, year) IN (SELECT product_id, MIN(year) 
                             FROM Sales
                             GROUP BY product_id);
2)
SELECT product_id, year AS first_year, quantity, price
FROM (SELECT *, RANK() OVER (PARTITION BY product_id ORDER BY year) AS rnk
      FROM Sales) t
WHERE rnk = 1;

"""

# 1077. Project Employees III
1)
WITH t AS (SELECT project_id, 
                  employee_id,
                  RANK() OVER (PARTITION BY project_id ORDER BY experience_years DESC) AS rnk
           FROM Project
           JOIN Employee 
           USING (employee_id))

SELECT project_id, employee_id
FROM t
WHERE rnk = 1;
2)
SELECT project_id, employee_id 
FROM Project 
JOIN Employee
USING (employee_id)
WHERE (project_id, experience_years) IN (SELECT project_id, MAX(experience_years)
                                         FROM Project
                                         JOIN Employee
                                         USING (employee_id)
                                         GROUP BY project_id);

"""

# 1098. Unpopular Books
1)
SELECT b.book_id, name 
FROM Books b
LEFT JOIN Orders o
ON b.book_id = o.book_id
WHERE DATEDIFF('2019-06-23', available_from) >= 30
GROUP BY 1, 2
HAVING SUM(IF(dispatch_date BETWEEN '2018-06-23' AND '2019-06-23', quantity, 0)) < 10;
2)
SELECT book_id, 
       name
FROM Books
WHERE available_from < '2019-05-23'
AND book_id NOT IN
            (SELECT book_id
             FROM Orders
             WHERE dispatch_date BETWEEN '2018-06-23' AND '2019-06-23'
             GROUP BY book_id
             Having sum(quantity) >= 10)
3)
SELECT b.book_id, b.name
FROM Books b
LEFT JOIN Orders o
ON b.book_id = o.book_id AND dispatch_date BETWEEN '2018-06-23' AND '2019-06-23'
WHERE DATEDIFF('2019-06-23', available_from) > 30
GROUP BY b.book_id, b.name
HAVING IFNULL(SUM(quantity), 0) < 10;

"""

# 1107. New Users Daily Count
1)
SELECT first_login AS login_date, COUNT(user_id) AS user_count
FROM (SELECT user_id, MIN(activity_date) as first_login
      FROM Traffic
      WHERE activity = 'login' 
      GROUP BY user_id) t
WHERE DATEDIFF('2019-06-30', first_login) <= 90
GROUP BY login_date;
2)
SELECT min_date AS login_date, COUNT(DISTINCT user_id) AS user_count
FROM (SELECT *, 
             MIN(activity_date) OVER (PARTITION BY user_id) AS min_date
      FROM Traffic
      WHERE activity = 'login') t
WHERE DATEDIFF('2019-06-30', min_date) <= 90
GROUP BY 1;
3)
SELECT activity_date AS login_date, COUNT(DISTINCT user_id) AS user_count
FROM Traffic 
WHERE DATEDIFF('2019-06-30', activity_date) <= 90
AND (user_id, activity_date) IN (SELECT user_id, MIN(activity_date)
                                 FROM Traffic
                                 WHERE activity = 'login'
                                 GROUP BY user_id
                                 )
GROUP BY login_date;

"""

# 1112. Highest Grade For Each Student
1)
SELECT student_id, MIN(course_id) AS course_id, grade
FROM Enrollments
WHERE (student_id, grade) IN (SELECT student_id, MAX(grade)
                              FROM Enrollments
                              GROUP BY student_id)
GROUP BY student_id, grade
ORDER BY 1;
2)
SELECT student_id, course_id, grade
FROM (SELECT *, 
      RANK() OVER (PARTITION BY student_id ORDER BY grade DESC, course_id ASC) AS rnk
      FROM Enrollments) t
WHERE rnk = 1;

"""

# 1126. Active Businesses
1)
WWITH t AS (
    SELECT event_type, AVG(occurences) AS avg
    FROM Events
    GROUP BY event_type
)
SELECT business_id
FROM Events e, t
WHERE e.occurences > avg AND t.event_type = e.event_type
GROUP BY business_id
HAVING COUNT(e.event_type) > 1
2)
SELECT business_id
FROM (SELECT *, AVG(occurences) OVER (PARTITION BY event_type) AS avg_o
      FROM Events) t 
WHERE occurences > avg_o
GROUP BY business_id
HAVING COUNT(*) > 1;
3)
SELECT business_id
FROM (
    SELECT *, AVG(occurences) OVER (PARTITION BY event_type) AS avg_occurences
    FROM events
    ) t
GROUP BY business_id 
HAVING SUM(occurences > avg_occurences) > 1;

"""

1132. Reported Posts II

WITH t AS (SELECT action_date, 100* COUNT(DISTINCT Removals.post_id) / COUNT(DISTINCT post_id) AS avg_r
           FROM Actions
           LEFT JOIN Removals 
           USING (post_id)
           WHERE extra = 'spam'
           GROUP BY action_date)
SELECT ROUND(AVG(avg_r), 2) AS average_daily_percent
FROM t 

"""

1149. Article Views II

SELECT DISTINCT viewer_id AS id
FROM Views
GROUP BY viewer_id, view_date
HAVING COUNT(DISTINCT article_id) > 1
ORDER BY id;

"""

1158. Market Analysis I
1)
SELECT user_id AS buyer_id, join_date, IFNULL(COUNT(order_id), 0) AS orders_in_2019
FROM Users
LEFT JOIN Orders
ON Users.user_id = Orders.buyer_id AND YEAR(order_date) = 2019  #If you use 'where' then those who doesn't have 2019 sale won't be joined at all
GROUP BY user_id, join_date;
2)
WITH new AS (SELECT buyer_id, COUNT(order_id) AS orders_tot
             FROM Orders
             WHERE YEAR(order_date)=2019
             GROUP BY buyer_id)
SELECT U.user_id AS buyer_id, U.join_date , IFNULL(orders_tot,0) AS orders_in_2019
FROM Users AS U
LEFT JOIN new
ON U.user_id=new.buyer_id
3)
select u.user_id as buyer_id, join_date, sum(case when YEAR(order_date) = '2019' then 1 else 0 end) as orders_in_2019
from Users u left join Orders o on u.user_id = o.buyer_id
group by u.user_id

"""

1164. Product Price at a Given Date
1)
SELECT DISTINCT Products.product_id, IFNULL(t.new_price, 10) AS price
FROM (SELECT *, RANK() OVER (PARTITION BY product_id ORDER BY change_date DESC) AS rnk
      FROM Products
      WHERE change_date <= '2019-08-16') t 
RIGHT JOIN Products 
ON t.product_id = Products.product_id AND rnk = 1 

2)
SELECT DISTINCT p.product_id, IFNULL(temp.new_price, 10) AS price 
FROM (SELECT *
      FROM Products
      WHERE (product_id, change_date) IN (SELECT product_id, MAX(change_date)
                                          FROM Products
                                          WHERE change_date <= '2019-08-16'
                                          GROUP BY product_id)) temp
RIGHT JOIN Products p
USING (Product_id);

3)
select distinct product_id, 10 as price
from Products
group by product_id
having (min(change_date) > "2019-08-16")
union
select p2.product_id, new_price
from Products p2
where (p2.product_id, p2.change_date) in (select product_id, max(change_date) as recent_date
                                          from Products
                                          where change_date <= "2019-08-16"
                                          group by product_id)

"""

1174. Immediate Food Delivery II
1)
WITH temp AS (
SELECT *, IF(order_date = customer_pref_delivery_date, 'immediate', 'scheduled') AS note
FROM Delivery
WHERE (customer_id, order_date) IN (SELECT customer_id, MIN(order_date)
                                    FROM Delivery
                                    GROUP BY customer_id))
SELECT ROUND(SUM(note = 'immediate') / COUNT(delivery_id) * 100, 2) AS immediate_percentage
FROM temp
2)
SELECT ROUND(SUM(order_date = customer_pref_delivery_date) / COUNT(delivery_id) * 100, 2) AS immediate_percentage
FROM Delivery
WHERE (customer_id, order_date) IN (SELECT customer_id, MIN(order_date)
                                    FROM Delivery
                                    GROUP BY customer_id)
3)
SELECT DISTINCT Products.product_id, IFNULL(t.new_price, 10) AS price
FROM (SELECT *, RANK() OVER (PARTITION BY product_id ORDER BY change_date DESC) AS rnk
      FROM Products
      WHERE change_date <= '2019-08-16') t 
RIGHT JOIN Products 
ON t.product_id = Products.product_id AND rnk = 1 
4)
SELECT ROUND(SUM(customer_pref_delivery_date = order_date) / COUNT(delivery_id) * 100, 2) AS immediate_percentage 
FROM (
    SELECT *, MIN(order_date) OVER (PARTITION BY customer_id) AS min_date
    FROM Delivery
) t
WHERE order_date = min_date;

"""

1193. Monthly Transactions I

SELECT DATE_FORMAT(trans_date, '%Y-%m') AS month,
       country,
       COUNT(id) AS trans_count,
       SUM(state = 'approved') AS approved_count,
       SUM(amount) AS trans_total_amount,
       SUM(IF(state = 'approved', amount, 0)) AS approved_total_amount
FROM Transactions
GROUP BY month, country;

"""

1204. Last Person to Fit in the Elevator
1)
SELECT q1.person_name
FROM Queue q1, Queue q2
WHERE q1.turn >= q2.turn
GROUP BY q1.turn
HAVING SUM(q2.weight) <= 1000
ORDER BY SUM(q2.weight) DESC
LIMIT 1
2)
SELECT person_name 
FROM (SELECT *, SUM(weight) OVER (ORDER BY turn) AS running_sum
      FROM Queue) t
WHERE running_sum <= 1000
ORDER BY running_sum DESC
LIMIT 1;

"""

1205. Monthly Transactions II
1)
WITH t AS (
    SELECT c.trans_id, DATE_FORMAT(c.trans_date, '%Y-%m') AS month, country, 'chargeback' AS state, amount
    FROM Chargebacks c  
    JOIN Transactions t  
    ON c.trans_id = t.id
    UNION
    SELECT t.id, DATE_FORMAT(t.trans_date, '%Y-%m') AS month, country, state, amount 
    FROM Transactions t)
    
SELECT month, country, SUM(state = 'approved') AS approved_count, SUM(IF(state = 'approved', amount, 0)) AS approved_amount, SUM(state = 'chargeback') AS chargeback_count, SUM(IF(state = 'chargeback', amount, 0)) AS chargeback_amount
FROM t 
GROUP BY month, country
HAVING approved_count + approved_amount + chargeback_count + chargeback_amount != 0 ;
2)
WITH t AS (
    SELECT LEFT(c.trans_date, 7) AS month, country, "chargeback" AS state, amount
    FROM chargebacks c
    JOIN transactions t ON c.trans_id = t.id
    UNION ALL
    SELECT LEFT(trans_date, 7) AS month, country, state, amount
    FROM transactions t
    WHERE state = "approved"    # If we do not filter out declined transactions at the beginning, we may get entries that have 0 for all four columns, which shouldn't be included in the result.
)
SELECT month, 
       country, 
       SUM(state = "approved") AS approved_count, 
       SUM(IF(state = 'approved', amount, 0)) AS approved_amount, 
       SUM(state = "chargeback") AS chargeback_count, 
       SUM(IF(state = "chargeback", amount, 0)) AS chargeback_amount
FROM t
GROUP BY month, country;

"""

1212. Team Scores in Football Tournament
1)
WITH temp AS (
    SELECT host_team AS team_id, 
    SUM(CASE WHEN host_goals > guest_goals THEN 3
             WHEN host_goals = guest_goals THEN 1
             ELSE 0 END) AS points
    FROM Matches 
    GROUP BY host_team
    UNION ALL
    SELECT guest_team AS team_id, 
           SUM(CASE WHEN guest_goals > host_goals THEN 3
           WHEN guest_goals = host_goals THEN 1
           ELSE 0 END) AS points
    FROM Matches
    GROUP BY guest_team
)
    
SELECT t.team_id, team_name, IFNULL(SUM(points), 0) AS num_points
FROM Teams t 
LEFT JOIN temp
USING (team_id)
GROUP BY 1, 2
ORDER BY num_points DESC, 1;
2)
SELECT team_id, team_name,
SUM(
    CASE WHEN team_id = host_team AND host_goals > guest_goals THEN 3
         WHEN team_id = guest_team AND guest_goals > host_goals THEN 3
         WHEN host_goals = guest_goals THEN 1
         ELSE 0
    END          
) AS "num_points"
FROM Teams t
LEFT JOIN Matches m ON t.team_id = m.host_team OR t.team_id = m.guest_team
GROUP BY team_id, team_name
ORDER BY num_points DESC, team_id;
3)
select team_id, team_name,
sum(case when team_id = host_team and host_goals > guest_goals then 3 else 0 end) +
sum(case when team_id = guest_team and guest_goals > host_goals then 3 else 0 end) +
sum(case when team_id = host_team and host_goals = guest_goals then 1 else 0 end) +
sum(case when team_id = guest_team and host_goals = guest_goals then 1 else 0 end)
as 'num_points'
from teams
left join matches
on team_id = host_team
or team_id = guest_team
group by team_id, team_name
order by num_points desc, team_id asc;

"""

1264. Page Recommendations
1)
SELECT DISTINCT page_id AS recommended_page
FROM Friendship f
JOIN Likes l
ON f.user1_id = l.user_id OR f.user2_id = l.user_id
WHERE (f.user1_id = 1 or f.user2_id = 1) 
AND page_id NOT IN (SELECT DISTINCT page_id
                      FROM Likes
                      WHERE user_id = 1)                   
2)
WITH t AS (
    SELECT user1_id, user2_id AS user_id
    FROM Friendship
    WHERE user1_id = 1
    UNION
    SELECT user2_id, user1_id AS user_id
    FROM Friendship
    WHERE user2_id = 1
)
SELECT DISTINCT page_id AS recommended_page
FROM t
JOIN Likes l
USINg (user_id)
WHERE page_id NOT IN (SELECT DISTINCT page_id
                      FROM Likes
                      WHERE user_id = 1)
3)
SELECT DISTINCT page_id as recommended_page
FROM (
    SELECT CASE WHEN user1_id = 1 then user2_id
                WHEN user2_id = 1 then user1_id
                END AS user_id
FROM Friendship) t
JOIN Likes l
on t.user_id = l.user_id
WHERE page_id NOT IN (SELECT DISTINCT page_id 
                      FROM Likes 
                      WHERE user_id = 1);

"""

1270. All People Report to the Given Manager
1)
SELECT e1.employee_id
FROM Employees e1
JOIN Employees e2
ON e1.manager_id = e2.employee_id
JOIN Employees e3
ON e2.manager_id = e3.employee_id
WHERE e3.manager_id = 1 AND e1.employee_id != 1
  
Alternative:
 SELECT e1.employee_id
FROM Employees e1,
     Employees e2,
     Employees e3
WHERE e1.manager_id = e2.employee_id
  AND e2.manager_id = e3.employee_id
  AND e3.manager_id = 1 
  AND e1.employee_id != 1
2)
with recursive cte1(id,n) as
(
    select employee_id as id, 1 as n
    from employees
    where manager_id=1 and employee_id!=1
    union
    select employee_id as id,n+1 as n
    from employees, cte1
    where manager_id=cte1.id and n+1<4
)
select id as employee_id 
from cte1
3)
SELECT a.employee_id as EMPLOYEE_ID 
FROM Employees as a      # those whose boss is 1
WHERE a.employee_id!=1 AND a.manager_id=1
UNION
SELECT b.employee_id 
FROM Employees as b      #those whose boss' boss is 1
WHERE b.manager_id IN (SELECT a.employee_id 
                       FROM Employees as a
                       WHERE a.employee_id!=1 AND a.manager_id=1)
UNION
SELECT c.employee_id FROM Employees as c      #those whose boss' boss' boss is 1
WHERE c.manager_id IN (SELECT b.employee_id 
                       FROM Employees as b
                       WHERE b.manager_id IN (SELECT a.employee_id 
                                              FROM Employees as a
                                              WHERE a.employee_id!=1 AND a.manager_id=1))
ORDER BY EMPLOYEE_ID;

"""

1285. Find the Start and End Number of Continuous Ranges
1)
# the difference of (log_id - num) will change whenever a log_id is skipped. The rows with same difference (log_id - num), 
should be a continuous series. Then we just need to find the min, and max for that series as start/ end id. 
log_id, num, difference
1, 1, 0
2, 2, 0
3, 3, 0
7, 4, 3
8, 5, 3
10, 6, 4

SELECT MIN(log_id) as start_id, MAX(log_id) AS end_id
FROM (SELECT log_id, 
             ROW_NUMBER() OVER(ORDER BY log_id) as num
      FROM Logs) a
GROUP BY log_id - num;
2)
select L1.log_id as START_ID, min(L2.log_id) as END_ID
from 
	(select log_id from Logs 
	where log_id-1 not in (select log_id from Logs)) L1,
	(select log_id from Logs 
	where log_id+1 not in (select log_id from Logs)) L2
where L1.log_id <= L2.log_id
group by L1.log_id

"""

1308. Running Total for Different Genders
1)
SELECT gender, day, SUM(score_points) OVER (PARTITION BY gender ORDER BY day) AS total
FROM Scores 
ORDER BY gender, day;
2)
SELECT s1.gender, s1.day, SUM(s2.score_points) AS total
FROM Scores AS s1,
     Scores AS s2
WHERE s1.gender = s2.gender AND s2.day <= s1.day
GROUP BY s1.gender, s1.day
ORDER BY s1.gender, s1.day

"""

1321. Restaurant Growth
1)
WITH temp AS (
    SELECT visited_on, 
           SUM(amount) OVER(ORDER BY visited_on ROWS BETWEEN 6 PRECEDING AND CURRENT ROW) AS amount,
           ROUND(AVG(amount) OVER(ORDER BY visited_on ROWS BETWEEN 6 PRECEDING AND CURRENT ROW), 2) AS average_amount
    FROM (SELECT visited_on, SUM(amount) AS amount
          FROM Customer
          GROUP BY visited_on) t
)
SELECT *
FROM temp 
WHERE DATE_SUB(visited_on, INTERVAL 6 DAY) IN (SELECT DISTINCT visited_on FROM Customer);

2) https://leetcode.com/problems/restaurant-growth/discuss/1005697/MySQL-Easy-to-Read-and-Faster-Than-85-(w-Window-Function)
with sum_table as (
select distinct visited_on,
sum(amount) over (order by visited_on range between interval 6 day preceding and current row) as amount,
-- note that we use range to get the preceding 6 days
dense_rank() over (order by visited_on) as days
-- we need to remove the first 6 days from the output, note that dense_rank() is used to avoid gap in rank
from Customer
)
select visited_on, amount, round(amount/7,2) as average_amount
from sum_table
where days >= 7;

3) fastest method
SELECT b.visited_on, 
       SUM(a.amount) AS amount, 
       ROUND(SUM(a.amount)/7,2) AS average_amount
FROM Customer a, 
     (SELECT DISTINCT visited_on 
      FROM Customer) b
WHERE DATEDIFF(b.visited_on, a.visited_on) BETWEEN 0 AND 6
GROUP BY b.visited_on
HAVING COUNT(DISTINCT a.visited_on) = 7

"""

1341. Movie Rating
1)
WITH t1 AS (SELECT name, 
                   RANK() OVER (ORDER BY COUNT(DISTINCT movie_id) DESC, name) AS rnk
            FROM Movie_Rating 
            JOIN Users USING (user_id)
            GROUP BY user_id),
     t2 AS (SELECT title,
                   RANK() OVER (ORDER BY AVG(rating) DESC, title) AS rnk
            FROM Movies
            JOIN Movie_Rating USING (movie_id)
            WHERE LEFT(created_at, 7) = '2020-02'
            GROUP BY title)    
SELECT name AS results
FROM t1
WHERE t1.rnk = 1
UNION
SELECT title As results
FROM t2
WHERE t2.rnk = 1;

2) https://leetcode.com/problems/movie-rating/discuss/502651/MySQL-solution-using-UNION-SELECT-and-GROUP-BY
SELECT user_name as results FROM
(
    SELECT b.name as user_name,COUNT(*) as counts FROM Movie_rating as a
    JOIN Users as b
    ON a.user_id=b.user_id
    GROUP BY a.user_id
    ORDER BY counts DESC,user_name ASC LIMIT 1
) first_query #query for the person who rates the greatest number of movies
UNION
SELECT movie_name as results FROM
(
    SELECT d.title as movie_name,AVG(c.rating) as grade FROM Movie_rating as c
    JOIN Movies as d
    ON c.movie_id=d.movie_id
    WHERE SUBSTR(c.created_at,1,7)="2020-02"
    GROUP BY c.movie_id
    ORDER BY grade DESC,movie_name ASC LIMIT 1
) second_query; #query for the movie with the highest average rating in February

3)
select name as results
from (select u.name, rank() over(order by count(*) desc, u.name) as rank
      from users u inner join movie_rating r
           on u.user_id = r.user_id
      group by u.name)
where rank = 1
union
select title
    from (select m.title,  rank() over(order by avg(rating) desc, m.title) as rank
          from movies m inner join movie_rating r
               on m.movie_id = r.movie_id
          where trunc(created_at, 'mm')='2020-02-01'
          group by m.title)
where rank = 1

4)
(SELECT name AS results
FROM Movie_Rating 
JOIN Users USING (user_id)
GROUP BY user_id
ORDER BY COUNT(DISTINCT movie_id) DESC, name
LIMIT 1)
UNION 
(SELECT title AS results
FROM Movie_Rating
JOIN Movies USING (movie_id)
WHERE DATE_FORMAT(created_at, '%Y-%m') = '2020-02'
GROUP BY movie_id
ORDER BY AVG(rating) DESC, title
LIMIT 1);

"""

1355. Activity Participants
1)
WITH t AS(
    SELECT activity,
           RANK() OVER (ORDER BY COUNT(id) DESC) AS rnk1,
           RANK() OVER (ORDER BY COUNT(id)) AS rnk2
    FROM Friends
    GROUP BY activity)
SELECT activity
FROM t 
WHERE rnk1 != 1 AND rnk2 != 1
2)
SELECT activity 
FROM friends
GROUP BY activity
HAVING COUNT(id) > (SELECT COUNT(id) 
                    FROM friends 
                    GROUP BY activity 
                    ORDER BY 1 
                    LIMIT 1)
AND COUNT(id) < (SELECT COUNT(id) 
                 FROM friends 
                 GROUP BY activity 
                 ORDER BY 1 DESC 
                 LIMIT 1); 
3)
SELECT activity
FROM (
    SELECT *, 
           COUNT(id) AS num,
           MIN(COUNT(id)) OVER () AS min_num,
           MAX(COUNT(id)) OVER () AS max_num
    FROM Friends
    GROUP BY activity
     ) t
JOIN Activities
ON t.activity = Activities.name
WHERE num NOT IN (min_num, max_num);

"""                 

1364. Number of Trusted Contacts of a Customer
1)
WITH temp AS (
    SELECT customer_id, 
           customer_name, 
           COUNT(contact_name) AS contacts_cnt, 
           SUM(CASE WHEN contact_email IN (SELECT email FROM Customers) THEN 1 ELSE 0 END) AS trusted_contacts_cnt
    FROM Contacts c1
    RIGHT JOIN Customers c2
    ON c1.user_id = c2.customer_id
    GROUP BY 1, 2)
SELECT invoice_id, customer_name, price, contacts_cnt, trusted_contacts_cnt
FROM temp
RIGHT JOIN invoices 
ON temp.customer_id = Invoices.user_id
ORDER BY invoice_id;

2)https://leetcode.com/problems/number-of-trusted-contacts-of-a-customer/discuss/562342/Easy-MS-SQL
select
    i.invoice_id,
    c.customer_name,
    i.price,
    count(con.user_id) as contacts_cnt,
    count(c2.email) as trusted_contacts_cnt
from invoices i
join customers c on c.customer_id = i.user_id
left join contacts con on con.user_id = c.customer_id
left join customers c2 on c2.email = con.contact_email
group by i.invoice_id, c.customer_name, i.price
order by i.invoice_id;

3) https://leetcode.com/problems/number-of-trusted-contacts-of-a-customer/discuss/900767/MySQL-with-CTE-simpler-than-most-of-the-answers-and-beats-98
WITH cte AS
(SELECT user_id, count(contact_email) contacts_cnt, SUM(contact_email IN (SELECT email FROM Customers)) trusted_contacts_cnt
FROM Contacts
GROUP BY 1)
SELECT i.invoice_id, c.customer_name, i.price, IFNULL(contacts_cnt, 0) contacts_cnt, IFNULL(trusted_contacts_cnt, 0) trusted_contacts_cnt
FROM Invoices i
LEFT JOIN Customers c
ON i.user_id = c.customer_id
LEFT JOIN cte
ON i.user_id = cte.user_id
ORDER BY 1;

4)
SELECT invoice_id, customer_name, price, COUNT(contact_email) AS contacts_cnt, SUM(IF(contact_email IN (SELECT email FROM Customers), 1, 0)) AS trusted_contacts_cnt
FROM Customers
JOIN Invoices
ON Invoices.user_id = Customers.customer_id
LEFT JOIN Contacts
ON Contacts.user_id = Customers.customer_id
GROUP BY invoice_id, customer_name, price
ORDER BY invoice_id

""""

1393. Capital Gain/Loss
SELECT stock_name, 
       SUM(IF(operation = 'Buy', - price, price)) AS capital_gain_loss
FROM Stocks
GROUP BY stock_name; 

"""

1398. Customers Who Bought Products A and B but Not C
1)
SELECT *
FROM Customers 
WHERE customer_id IN (SELECT customer_id
                    FROM Orders
                    GROUP BY customer_id
                    HAVING SUM(product_name = 'A') > 0
                    AND SUM(product_name = 'B') > 0
                    AND SUM(product_name = 'C') = 0)
2)
select a.customer_id, a.customer_name
from customers a , orders b
where a.customer_id  = b.customer_id
group by a.customer_id
having sum(b.product_name="A") >0 and sum(b.product_name="B") > 0 and sum(b.product_name="C")=0

3) https://leetcode.com/problems/customers-who-bought-products-a-and-b-but-not-c/discuss/563827/100-Left-Outer-Join
SELECT c.customer_id, c.customer_name
FROM Customers c
JOIN Orders a ON a.customer_id = c.customer_id AND a.product_name = "A"
JOIN Orders b ON b.customer_id = c.customer_id AND b.product_name = "B"
LEFT OUTER JOIN Orders o on o.customer_id = c.customer_id AND o.product_name = "C"
WHERE o.order_id IS NULL;

"""

1421. NPV Queries
1)
SELECT q.id, q.year, IFNULL(n.npv, 0) AS npv
FROM NPV n
RIGHT JOIN Queries q
ON n.id = q.id AND n.year = q.year;

2)
SELECT id, year, IFNULL(npv, 0) AS npv
FROM Queries
LEFT JOIN NPV
USING (id, year);

"""

1440. Evaluate Boolean Expression
SELECT e.left_operand, e.operator, e.right_operand,
       CASE WHEN operator = '<' AND v1.value < v2.value THEN 'true'
            WHEN operator = '>' AND v1.value > v2.value THEN 'true'
            WHEN operator = '=' AND v1.value = v2.value THEN 'true'
            ELSE 'false' END AS value
FROM Variables v1
JOIN Expressions e
ON v1.name  = e.left_operand
JOIN Variables v2
ON v2.name = e.right_operand; 

"""

1445. Apples & Oranges

SELECT sale_date,
       SUM(IF(fruit = 'oranges', -1 * sold_num, sold_num)) AS diff
FROM Sales
GROUP BY sale_date
ORDER BY sale_date;

"""

1454. Active Users

1)https://leetcode.com/problems/active-users/discuss/642956/Simple-MySQL-solution-without-window-function
https://leetcode.com/problems/active-users/discuss/642645/MS-SQL-JOIN-AND-GROUP-BY
SELECT DISTINCT l1.id, A.name
FROM Logins l1
JOIN Logins l2
ON l1.id = l2.id AND DATEDIFF(l2.login_date, l1.login_date) BETWEEN 1 AND 4
JOIN Accounts A
ON l1.id = A.id
GROUP BY l1.id, l1.login_date
HAVING COUNT(DISTINCT l2.login_date) = 4;

2)
WITH t2 AS (
    SELECT id, 
           name, 
           login_date,
           lead(login_date, 4) OVER (PARTITION BY id ORDER BY login_date) AS lead_date
    FROM (SELECT DISTINCT id, login_date
          FROM Logins) t
JOIN Accounts USING (id)
    )
SELECT DISTINCt id, name
FROM t2 
WHERE DATEDIFF(lead_date, login_date) = 4;

"""

1459. Rectangles Area
1)
Alternative: replace 'AND a.x_value != b.x_value AND a.y_value != b.y_value' with 'ABS(a.x_value - b.x_value) * ABS(a.y_value - b.y_value) != 0' 
SELECT a.id AS p1, 
       b.id AS p2, 
       ABS(a.x_value - b.x_value) * ABS(a.y_value - b.y_value) AS area
FROM Points a, Points b
WHERE a.id < b.id
AND a.x_value != b.x_value
AND a.y_value != b.y_value 
ORDER BY area DESC, p1, p2;

2)
SELECT p1.id AS p1, p2.id AS p2, ABS((p2.x_value - p1.x_value) * (p2.y_value - p1.y_value)) AS area
FROM Points p1, Points p2
WHERE p1.id < p2.id
HAVING area != 0
ORDER BY area DESC, p1.id, p2.id; 

"""

1468. Calculate Salaries
1) faster 
SELECT company_id, 
       employee_id, 
       employee_name,
       ROUND(CASE WHEN MAX(salary) OVER (PARTITION BY company_id) < 1000 THEN salary
                  WHEN MAX(salary) OVER (PARTITION BY company_id) BETWEEN 1000 AND 10000 THEN salary * (1 - 0.24) 
                  ELSE salary * (1- 0.49) END) AS salary
FROM salaries
2)
WITH t AS (
    SELECT *,
           MAX(salary) OVER (PARTITION BY company_id) AS max_salary,
           CASE WHEN MAX(salary) OVER (PARTITION BY company_id) < 1000 THEN 0
                     WHEN MAX(salary) OVER (PARTITION BY company_id) BETWEEN 1000 AND 10000 THEN 0.24
                     ELSE 0.49 END AS tax_rate
FROM Salaries
    )
SELECT company_id, employee_id, employee_name, ROUND(salary * (1 - tax_rate)) AS salary
FROM t;
3)
WITH rate AS (
SELECT company_id, 
       CASE WHEN MAX(salary) < 1000 THEN 0
            WHEN MAX(salary) BETWEEN 1000 AND 10000 THEN 0.24
            ELSE 0.49 END AS tax_rate
FROM Salaries 
GROUP BY company_id
    )
SELECT company_id, employee_id, employee_name, 
       ROUND(salary * (1 - tax_rate)) AS salary
FROM rate
JOIN Salaries USING (company_id)

"""

1501. Countries You Can Safely Invest In
1)
SELECT Country.name AS country
FROM Country 
JOIN Person 
ON LEFT(Person.phone_number, 3) = Country.country_code 
JOIN Calls 
ON Calls.caller_id = Person.id OR Calls.callee_id = Person.id 
GROUP BY Country.name 
HAVING AVG(Calls.duration) > (SELECT AVG(duration)
                              FROM Calls)
2)
WITH t AS (
    SELECT caller_id AS id, duration
    FROM calls
    UNION ALL
    SELECT callee_id AS id, duration
    FROM calls
)
SELECT c.name AS country
FROM t
JOIN Person p USING (id)
JOIN Country c
ON c.country_code = LEFT(p.phone_number, 3)
GROUP BY country
HAVING AVG(duration) > (SELECT AVG(duration)
                        FROM Calls);
3)
SELECT DISTINCT country 
FROM (
    SELECT country.name country, 
           calls.duration,
           AVG(calls.duration) over(partition by country.name) avg_duration,
           AVG(calls.duration) over() avg_total
    FROM calls  
    JOIN person ON calls.caller_id = person.id or calls.callee_id = person.id
    JOIN country ON LEFT(person.phone_number, 3) = country.country_code
) t
WHERE avg_duration > avg_total;

"""

1532. The Most Recent Three Orders
1)
SSELECT name AS customer_name, customer_id, order_id, order_date
FROM (
    SELECT name,
           customer_id, 
           order_date,
           order_id,
           cost,
           RANK() OVER (PARTITION BY customer_id ORDER BY order_date DESC) AS rnk
FROM Customers  
JOIN Orders 
USING (customer_id)) t 
WHERE rnk <= 3
ORDER BY customer_name, customer_id, order_date DESC;

2)
SELECT
 c.name AS customer_name, o1.customer_id, o1.order_id, o1.order_date
FROM
 orders o1
 LEFT JOIN
      orders o2
      ON o1.customer_id = o2.customer_id
      AND o1.order_date < o2.order_date
 INNER JOIN
       customers c
       ON o1.customer_id = c.customer_id
GROUP BY
 o1.customer_id, c.name, o1.order_id, o1.order_date
HAVING
 COUNT(o2.order_date) <= 2
ORDER BY
 c.name, o1.customer_id, o1.order_date desc;

"""

1549. The Most Recent Orders for Each Product
1)
SELECT product_name,  product_id, order_id, order_date
FROM (SELECT product_name, 
             product_id, 
             order_id, 
             order_date, 
             RANK() OVER (PARTITION BY product_id ORDER BY order_date DESC) AS rnk
      FROM Orders 
      JOIN Products USING (product_id)) t
WHERE rnk = 1 
ORDER BY 1, 2, 3;
2)
SELECT b.product_name, a.product_id, a.order_id, a.order_date 
FROM Orders a
JOIN Products b 
USING (product_id)
WHERE (a.product_id, a.order_date) IN (SELECT product_id, MAX(order_date) AS order_date
                                       FROM Orders
                                       GROUP BY product_id)
ORDER BY b.product_name, a.product_id, a.order_id;
3)
WITH t1 AS (
    SELECT p.product_name, p.product_id, max(o.order_date) as order_date
    FROM Orders o
    JOIN Products p 
    USING(product_id)
    GROUP BY 1
)
SELECT t1.product_name, t1.product_id, o.order_id, t1.order_date
FROM Orders o
JOIN t1 
ON o.order_date = t1.order_date AND t1.product_id = o.product_id
ORDER BY 1 ASC, 2 ASC, 3 ASC;

"""

1555. Bank Account Summary
1)
SELECT user_id, 
       user_name, 
       IFNULL(SUM(IF(user_id = paid_by, -amount, amount)), 0) + credit AS credit, 
       CASE WHEN IFNULL(SUM(IF(user_id = paid_by, -amount, amount)), 0) + credit > 0 THEN 'No' ELSE 'Yes' END AS credit_limit_breached
FROM Users u
LEFT JOIN Transactions t
ON u.user_id = t.paid_to OR u.user_id  = t.paid_by
GROUP BY u.user_id;
2)
WITH t AS(
    SELECT paid_by AS user_id, SUM(-amount) AS amount
    FROM Transactions 
    GROUP BY paid_by
    UNION ALL
    SELECT paid_to AS user_id, SUM(amount) AS amount
    FROM Transactions
    GROUP BY paid_to
    )
SELECT user_id, 
       user_name, 
       IFNULL(SUM(amount), 0) + credit AS credit,
       IF(IFNULL(SUM(amount), 0) + credit > 0, 'No', 'Yes') AS credit_limit_breached
FROM Users
LEFT JOIN t USING (user_id)
GROUP BY user_id, user_name;
3)
SELECT user_id, user_name, IFNULL(SUM(IF(type = 'pay', -amount, amount)), 0) + credit AS credit, IF(IFNULL(SUM(IF(type = 'pay', -amount, amount)), 0) + credit > 0, 'No', 'Yes') AS credit_limit_breached
FROM (SELECT paid_by AS user_id, 'pay' AS type, amount 
      FROM Transactions
      UNION ALL
      SELECT paid_to AS user_id, 'receive' AS type, amount
      FROM Transactions
      ) t
RIGHT JOIN Users USING (user_id)
GROUP BY 1, 2;

"""

1596. The Most Frequently Ordered Products for Each Customer
1)
SELECT customer_id, product_id, product_name
FROM (
SELECT customer_id, product_id, product_name,
       RANK() OVER (PARTITION BY customer_id ORDER BY COUNT(product_id) DESC) AS rnk
FROM Customers
LEFT JOIN Orders USING (customer_id)
JOIN Products USING (product_id)
GROUP BY customer_id, product_id
    ) t
WHERE rnk = 1;
2)
SELECT customer_id,products.product_id,product_name
from Orders
JOIN Products on Products.product_id=Orders.product_id
group by customer_id,product_id
HAVING (customer_id,COUNT(order_date)) IN(
#Get Maxiumum Count for each customer 
SELECT customer_id,MAX(cnt)FROM
(
SELECT customer_id,product_id,COUNT(order_date) as cnt
from Orders
group by customer_id,product_id
) as a
group by customer_id)

"""

1613. Find the Missing IDs

WITH RECURSIVE t AS (
    SELECT 1 as num
    UNION 
    SELECT num + 1
    FROM t
    WHERE num < (SELECT MAX(customer_id) FROM Customers) 
)
SELECT num AS ids
FROM t
WHERE num NOT IN (SELECT customer_id FROM Customers);  

"""

1699. Number of Calls Between Two Persons
1)
SELECT LEAST(from_id,to_id) as person1,
GREATEST(from_id,to_id) as person2,
COUNT(*) as call_count,
SUM(duration) as total_duration
FROM Calls
GROUP BY person1,person2;
2)
WITH t AS (
    SELECT *
    FROM Calls 
    UNION ALL
    SELECT to_id AS from_id, from_id AS to_id, duration
    FROM Calls)
SELECT from_id AS person1, to_id AS person2, COUNT(*) AS call_count, SUM(duration) AS total_duration
FROM t 
WHERE from_id < to_id
GROUP BY 1, 2;
3)
SELECT CASE WHEN from_id > to_id THEN to_id
            ELSE from_id END AS person1,
       CASE WHEN from_id > to_id THEN from_id
            ELSE to_id END AS person2,
       COUNT(duration) AS call_count,
       SUM(duration) AS total_duration       
FROM Calls
GROUP BY person2, person1;

"""

1709. Biggest Window Between Visits
1)
WITH t AS (
    SELECT *,
           LEAD(visit_date, 1, '2021-1-1') OVER (PARTITION BY user_id ORDER BY visit_date) AS lead_date
    FROM UserVisits)

SELECT user_id, MAX(DATEDIFF(lead_date, visit_date)) AS biggest_window
FROM t 
GROUP BY user_id;
2)
SELECT user_id, MAX(diff) AS biggest_window
FROM
(
SELECT user_id,
DATEDIFF(LEAD(visit_date, 1, '2021-01-01') OVER (PARTITION BY user_id ORDER BY visit_date), visit_date) AS diff
	FROM userVisits
) a
GROUP BY user_id
ORDER BY user_id;

"""

1715. Count Apples and Oranges

SELECT SUM(b.apple_count) + IFNULL(SUM(c.apple_count), 0) AS apple_count,
       SUM(b.orange_count) + IFNULL(SUM(c.orange_count), 0) AS orange_count 
FROM Boxes b
LEFT JOIN Chests c 
USING (chest_id);

"""

1747. Leetflex Banned Accounts
1)
SELECT DISTINCT a.account_id
FROM loginfo a JOIN loginfo b 
ON a.account_id = b.account_id AND a.ip_address < b.ip_address
WHERE GREATEST(a.login, b.login) <= LEAST(a.logout, b.logout)
2)
SELECT DISTINCT a.account_id
FROM LogInfo a, LogInfo b
WHERE a.login between (b.login) and (b.logout)
AND a.account_id = b.account_id
AND a.ip_address !=b.ip_address;

"""

1783. Grand Slam Titles
1)
WITH t AS (
    SELECT Wimbledon AS player_id FROM Championships
    UNION ALL
    SELECT Fr_open AS player_id FROM Championships
    UNION ALL
    SELECT US_open AS player_id FROM Championships
    UNION ALL
    SELECT Au_open AS player_id FROM Championships
    )
SELECT player_id, player_name, COUNT(*) AS grand_slams_count
FROM Players
JOIN t USING (player_id)
GROUP BY player_id;
2)
SELECT player_id,
       player_name,
       SUM(player_id = Wimbledon) + SUM(player_id = Fr_open) + SUM(player_id = US_open) + SUM(player_id = Au_open) AS grand_slams_count
FROM Players
JOIN Championships
ON player_id = Wimbledon OR player_id = Fr_open OR player_id = US_open OR player_id = Au_open
GROUP BY player_id;

"""

1811. Find Interview Candidates

WITH t1 AS (SELECT gold_medal
            FROM Contests
            GROUP BY gold_medal
            HAVING COUNT(contest_id) >= 3),
     t2 AS (SELECT contest_id, gold_medal AS user_id FROM contests
            UNION ALL
            SELECT contest_id, silver_medal AS user_id FROM contests
            UNION ALL
            SELECT contest_id, bronze_medal AS user_id FROM contests), 
     t3 AS (SELECT user_id, contest_id, LEAD(contest_id, 2) OVER (PARTITION BY user_id ORDER BY contest_id) AS lag_contest
            FROM t2)
            
SELECT name, mail
FROM Users 
WHERE user_id IN (SELECT gold_medal FROM t1)
OR user_id IN (SELECT user_id
               FROM t3
               WHERE lag_contest - contest_id = 2);
               
2) https://leetcode.com/problems/find-interview-candidates/discuss/1142921/CTE-3-times-Union-All-with-Explanation
WITH t1 AS (SELECT contest_id, gold_medal AS user_id, gold_medal
            FROM Contests
            UNION ALL
            SELECT contest_id, silver_medal AS user_id, gold_medal
            FROM Contests
            UNION ALL
            SELECT contest_id, bronze_medal AS user_id, gold_medal
            FROM Contests),
    t2 AS (SELECT gold_medal AS user_id
           FROM Contests 
           GROUP BY user_id
           HAVING COUNT(gold_medal) >= 3),
    t3 AS (SELECT contest_id, user_id
           FROM t1
           WHERE (contest_id + 1, user_id) IN (SELECT contest_id, user_id FROM t1)
           AND (contest_id + 2, user_id) IN (SELECT contest_id, user_id FROM t1))
SELECT name, mail
FROM t2
JOIN Users USING (user_id)
UNION 
SELECT name, mail
FROM t3
JOIN Users USING (user_id);

Alternative:
select name, mail
        from users
        where user_id in (select gold_medal from t1)
        or user_id in (select user_id from t3);

3) https://leetcode.com/problems/find-interview-candidates/discuss/1144024/MySQL-Short-and-sweet-using-lag()-function
WITH cte AS (
    SELECT
        user_id,
        name,
        mail,
        contest_id,
        user_id = gold_medal as gold,
        user_id = silver_medal as silver,
        user_id = bronze_medal as bronze,
        lag(contest_id, 2) over (partition by user_id order by contest_id) as lag_contest
    FROM Users
    LEFT JOIN Contests 
    ON user_id = gold_medal OR user_id = silver_medal OR user_id = bronze_medal
)

SELECT name, mail
FROM cte
GROUP BY user_id
HAVING SUM(gold) >= 3
OR SUM(contest_id - lag_contest = 2) >= 1

"""

1831. Maximum Transaction Each Day
1)
SELECT transaction_id
FROM (
    SELECT transaction_id,
    DATE(day) AS day,
    amount,
    RANK() OVER (PARTITION BY DATE(day) ORDER BY amount DESC) AS rnk
    FROM Transactions 
    ) t
WHERE rnk = 1
ORDER BY 1;

2)
SELECT transaction_id 
FROM transactions 
WHERE (DATE(day), amount) IN (SELECT DATE(day) AS day, MAX(amount)
                              FROM transactions 
                              GROUP BY 1)
ORDER BY 1;

"""

1841. League Statistics
1) https://leetcode.com/problems/league-statistics/discuss/1224551/MySQL-simplify-by-making-away-teams-home
SELECT team_name, 
       COUNT(*) AS matches_played, 
       SUM(CASE WHEN goal_for > goal_against THEN 3
                WHEN goal_for = goal_against THEN 1
                ELSE 0 END) AS points, 
       SUM(goal_for) AS goal_for, 
       SUM(goal_against) AS goal_against, 
       SUM(goal_for - goal_against) AS goal_diff
FROM (SELECT home_team_id AS team_id, home_team_goals AS goal_for, away_team_goals AS goal_against 
      FROM Matches
      UNION ALL
      SELECT away_team_id AS team_id, away_team_goals AS goal_for, home_team_goals AS goal_against
      FROM Matches) t
JOIN Teams USING (team_id)
group by 1
order by 3 desc, 6 desc, 1;

2)
WITH t AS ( 
    SELECT t.team_name,
           CASE WHEN t.team_id = m.home_team_id and home_team_goals > away_team_goals THEN 3
                WHEN home_team_goals = away_team_goals THEN 1
                WHEN t.team_id = m.away_team_id and home_team_goals < away_team_goals THEN 3
                ELSE 0 END as points,
            CASE WHEN t.team_id = m.home_team_id THEN home_team_goals ELSE away_team_goals END AS goal_for,
            CASE WHEN t.team_id = m.away_team_id THEN home_team_goals ELSE away_team_goals END AS goal_against
    FROM teams t
    JOIN matches m
    ON t.team_id = m.home_team_id OR t.team_id = m.away_team_id
    )
SELECT team_name, 
        COUNT(team_name) AS matches_played,
        SUM(points) as points,
        sum(goal_for) as goal_for,
        sum(goal_against) as goal_against,
        sum(goal_for-goal_against) as goal_diff
FROM t
GROUP BY team_name
ORDER BY points DESC, goal_diff DESC, team_name;

3) https://leetcode.com/problems/league-statistics/discuss/1226809/MySQL-fun-times
WITH t AS (
    SELECT t.team_name, m.home_team_id AS team_id, m.home_team_goals AS goals,
           CASE WHEN m.home_team_goals > m.away_team_goals THEN 3
                 WHEN m.home_team_goals = m.away_team_goals THEN 1
                 ELSE 0 END AS points,
           m.away_team_goals AS goal_against
    FROM Matches m 
    LEFT JOIN Teams t ON m.home_team_id = t.team_id
    UNION ALL
    SELECT t.team_name, m.away_team_id AS team_id, m.away_team_goals AS goals,
           CASE WHEN m.away_team_goals > m.home_team_goals THEN 3
                 WHEN m.away_team_goals = m.home_team_goals THEN 1
                 ELSE 0 END AS points,
           m.home_team_goals AS goal_against
    FROM Matches m 
    LEFT JOIN Teams t ON m.away_team_id = t.team_id
)
SELECT team_name,
       COUNT(*) AS matches_played,
       SUM(points) AS points,
       SUM(goals) AS goal_for,
       SUM(goal_against) AS goal_against,
       (SUM(goals) - SUM(goal_against)) AS goal_diff
FROM t
GROUP BY team_name
ORDER BY points DESC, goal_diff DESC, team_name;

"""

1843. Suspicious Bank Accounts
1)
WITH t AS (SELECT account_id, DATE_FORMAT(day, '%Y%m') AS month, SUM(amount) AS total, max_income
           FROM Transactions
           JOIN Accounts USING (account_id)
           WHERE type = 'Creditor'
           GROUP BY 1, 2
           HAVING total > max_income)
SELECT DISTINCT account_id
FROM t
WHERE (account_id, month + 1) IN (SELECT account_id, month
                                  FROM t);

Alternative: SELECT DISTINCT t1.account_id
             FROM t t1, t t2
             WHERE t1.account_id = t2.account_id 
             AND t1.month + 1 = t2.month

2)
WITH t1 AS (
    SELECT account_id, MONTH(day) AS month, SUM(amount) AS total
    FROM Transactions
    WHERE type = 'Creditor'
    GROUP BY 1, 2), 
     t2 AS (
         SELECT account_id,
                month,
                total, 
                max_income,
                LEAD(total) OVER (PARTITION BY account_id ORDER BY month) AS lead_total,
                LEAD(month) OVER (PARTITION BY account_id ORDER BY month) AS lead_month
         FROM t1
         JOIN Accounts USING (account_id))
SELECT DISTINCT account_id
FROM t2
WHERE lead_month - month = 1
AND lead_total > max_income
AND total > max_income;
3)
WITH t AS (
    SELECT account_id, 
           DATE_FORMAT(day,'%Y%m') AS date, 
           IF(SUM(amount) > max_income, 'Y', 'N') AS suspicious
    FROM transactions 
    JOIN accounts USING (account_id)
    WHERE type = 'Creditor'
    GROUP BY account_id, date
)

SELECT DISTINCT t1.account_id
FROM t t1, t t2
WHERE t1.account_id = t2.account_id 
AND PERIOD_DIFF(t1.date, t2.date)=1
AND t1.suspicious = 'Y' and t2.suspicious = 'Y';

"""

1867. Orders With Maximum Quantity Above Average
1) 
WITH t AS (
    SELECT DISTINCT order_id,
           AVG(quantity) OVER (PARTITION BY order_id) AS avg_q,
           MAX(quantity) OVER (PARTITION BY order_id) AS max_q
    FROM OrdersDetails
    )
SELECT order_id
FROM t 
WHERE max_q > (SELECT MAX(avg_q)
               FROM t)
2)
WITH t AS (
    SELECT order_id,
           AVG(quantity) AS avg_q,
           MAX(quantity) AS max_q
    FROM OrdersDetails
    GROUP BY order_id
)
SELECT order_id
FROM t
WHERE max_q > (SELECT MAX(avg_q)
               FROM t);
3）
SELECT order_id
FROM OrdersDetails
GROUP BY order_id
HAVING MAX(quantity) > ALL (SELECT AVG(quantity) 
                            FROM OrdersDetails
                            GROUP BY order_id);

"""

1875. Group Employees of the Same Salary
1)
SELECT employee_id, 
       name, 
       salary,
       DENSE_RANK() OVER (ORDER BY salary) AS team_id
FROM Employees
WHERE salary NOT IN (SELECT salary
                     FROM Employees
                     GROUP BY salary
                     HAVING COUNT(employee_id) = 1)
Alternative:
WHERE salary IN (SELECT salary
                 FROM Employees
                 GROUP BY Salary
                 HAVING COUNT(employee_id) > 1)
		 
2)
WITH team AS (
    SELECT salary, ROW_NUMBER() OVER(ORDER BY salary) as team_id
    FROM Employees
    GROUP BY salary
    HAVING COUNT(employee_id) >= 2
    )
SELECT employee_id, name, e.salary, team_id
FROM Employees e
JOIN team t
ON e.salary = t.salary
ORDER BY team_id, employee_id;

"""

1907. Count Salary Categories
1) 
WITH t1 AS (
    SELECT account_id, 
           CASE WHEN income < 20000 THEN 'Low Salary'
                WHEN income BETWEEN 20000 AND 50000 THEN 'Average Salary'
                ELSE 'High Salary' END AS category
    FROM Accounts 
    ),
    t2 AS (                                   # need a table of category to make left join, prevent  those category without value in CTE from disappearing 
        SELECT 'Low Salary' AS category
        UNION 
        SELECT 'Average Salary' AS category
        UNION
        SELECT 'High Salary' AS category
    )                     
SELECT t2.category, COUNT(account_id) AS accounts_count
FROM t2
LEFT JOIN t1 USING (category)
GROUP BY 1

2)
SELECT 'Low Salary' AS category, SUM(income < 20000) AS accounts_count
FROM Accounts
UNION 
SELECT 'Average Salary' AS category, SUM(income BETWEEN 20000 AND 50000) AS accounts_count
FROM Accounts
UNION
SELECT 'High Salary' AS category, SUM(income > 50000) AS accounts_count
FROM Accounts

"""

1934. Confirmation Rate

SELECT s.user_id, IFNULL(ROUND(SUM(action = 'confirmed') / COUNT(action), 2), 0) AS confirmation_rate
FROM Signups s
LEFT JOIN Confirmations c
USING (user_id)
GROUP BY s.user_id;

"""

1949. Strong Friendship

WITH t AS (
SELECT user1_id AS id, user2_id AS friend_id
FROM Friendship
UNION ALL
SELECT user2_id AS id, user1_id AS friend_id
FROM Friendship
    )
SELECT f.user1_id, f.user2_id, COUNT(*) AS common_friend
FROM Friendship f, t t1, t t2
WHERE f.user1_id = t1.id 
AND f.user2_id = t2.id
AND t1.friend_id = t2.friend_id
GROUP BY 1, 2 
HAVING COUNT(*) >= 3;

"""

1951. All the Pairs With the Maximum Number of Common Followers
1)
WITH t AS (
    SELECT r1.user_id AS user1_id, r2.user_id AS user2_id, COUNT(*) AS common
    FROM Relations r1, Relations r2
    WHERE r1.user_id < r2.user_id
    AND r1.follower_id = r2.follower_id 
    GROUP BY user1_id, user2_id
    )
SELECT user1_id, user2_id
FROM t
WHERE common = (SELECT MAX(common)
                FROM t);

2)
SELECT user1_id, user2_id
FROM(
    SELECT r1.user_id AS user1_id, r2.user_id AS user2_id, DENSE_RANK() OVER (ORDER BY COUNT(*) DESC) rnk 
    FROM Relations r1, Relations r2
    WHERE r1.user_id < r2.user_id AND r1.follower_id = r2.follower_id
    GROUP BY r1.user_id, r2.user_id) temp
    WHERE rnk=1;
    
"""

1988. Find Cutoff Score for Each School
1)
SELECT school_id, IFNULL(MIN(score), -1) AS score
FROM Schools
LEFT JOIN Exam
ON capacity >= student_count
GROUP BY school_id;

2)
SELECT school_id, MIN(score) AS score
FROM Schools, Exam
WHERE student_count <= capacity 
GROUP BY school_id
UNION
SELECT school_id, -1 AS score
FROM Schools
WHERE capacity < (SELECT MIN(student_count)
                  FROM Exam)

"""

1990. Count the Number of Experiments

WITH t1 AS (
    SELECT 'Android' AS platform
    UNION
    SELECT 'IOS' AS platform
    UNION
    SELECT 'Web' AS platform),
     t2 AS (
         SELECT 'Reading' AS experiment_name
         UNION
         SELECT 'Sports' AS experiment_name
         UNION
         SELECT 'Programming' AS experiment_name
         )
SELECT t1.platform, t2.experiment_name, COUNT(e.experiment_id) AS num_experiments
FROM t1
CROSS JOIN t2
LEFT JOIN Experiments e
USING (platform, experiment_name)
GROUP BY 1, 2;

"""

2020. Number of Accounts That Did Not Stream
1) Alternative: end_date >= '2021-01-01'
SELECT COUNT(s1.account_id) AS accounts_count
FROM Subscriptions s1
JOIN Streams s2
ON s1.account_id = s2.account_id 
AND YEAR(end_date) >= 2021
AND YEAR(stream_date) != 2021;

2)
SELECT COUNT(account_id) AS accounts_count
FROM Subscriptions 
WHERE YEAR(end_date) >= 2021
AND account_id NOT IN (SELECT account_id
                       FROM Streams
                       WHERE YEAR(stream_date) = 2021);
		       
"""
